# ğŸ§© Digilent Basys3 Verilog ìˆœì°¨íšŒë¡œ ëª¨ë¸ë§

## ğŸ¯ í•™ìŠµëª©í‘œ
- ëª¨ë¸ë§ì˜ ê¸°ë³¸ ë‹¨ìœ„ì¸ **ëª¨ë“ˆ**ì„ ì´í•´í•œë‹¤.  
- ëŒ€í‘œì ì¸ **ìˆœì°¨íšŒë¡œ**ë¥¼ ëª¨ë¸ë§í•  ìˆ˜ ìˆë‹¤.  
- **ìœ í•œìƒíƒœë¨¸ì‹ (FSM)** ì˜ ê°œë…ì„ ì´í•´í•œë‹¤.  
- **Mealy FSM** ê³¼ **Moore FSM** ì˜ ì°¨ì´ë¥¼ ì´í•´í•œë‹¤.  
- Mealy/Moore FSMì„ **Verilog**ë¡œ ëª¨ë¸ë§í•  ìˆ˜ ìˆë‹¤.  

---

## ğŸ“š ëª©ì°¨
1. [ìˆœì°¨íšŒë¡œ ê°œìš”](#1-ìˆœì°¨íšŒë¡œcombinational-circuit)
2. [ë˜ì¹˜ì™€ í”Œë¦½í”Œë¡­](#2-ë˜ì¹˜ì™€-í”Œë¦½í”Œë¡­)
3. [ì‹œí”„íŠ¸ ë ˆì§€ìŠ¤í„°](#3-ì‹œí”„íŠ¸-ë ˆì§€ìŠ¤í„°)
4. [ì¹´ìš´í„°](#4-ì¹´ìš´í„°)
5. [ì£¼íŒŒìˆ˜ ë¶„ì£¼ê¸°](#5-ì£¼íŒŒìˆ˜-ë¶„ì£¼ê¸°)
6. [7-ì„¸ê·¸ë¨¼íŠ¸ ë””ì½”ë”/ë“œë¼ì´ë²„](#6-7-ì„¸ê·¸ë¨¼íŠ¸-ë””ì½”ë”)
7. [ìœ í•œìƒíƒœë¨¸ì‹ (FSM)](#7-ìœ í•œìƒíƒœë¨¸ì‹ fsm)

---

## 1. ìˆœì°¨íšŒë¡œ(Combinational circuit)

### â–¶ ìˆœì°¨íšŒë¡œ
- ì‹œê°„ì˜ íë¦„ì— ë”°ë¼ **ìƒíƒœ(state)** ê°€ ë³€í•¨  
- ìƒíƒœëŠ” **ê³¼ê±° ìƒíƒœ + í˜„ì¬ ì…ë ¥**ì˜ ì¡°í•©ìœ¼ë¡œ ê²°ì •  
- **ê¸°ì–µì†Œì O** (ìƒíƒœ ë ˆì§€ìŠ¤í„°, ì¹´ìš´í„°, íƒ€ì´ë¨¸)

### â–¶ ë™ê¸°ì‹ ìˆœì°¨íšŒë¡œ
- **í´ë¡ì˜ ì—£ì§€**ì—ì„œë§Œ ìƒíƒœ ì „ì´  
- ëª…í™•í•œ ì‹œê°„ ê°„ê²©ì— ë”°ë¼ ì¶œë ¥ì´ ë³€í•¨

### â–¶ ë¹„ë™ê¸°ì‹ ìˆœì°¨íšŒë¡œ
- í´ë¡ê³¼ ë¬´ê´€í•˜ê²Œ **ì„ì˜ ì‹œì ì˜ ì…ë ¥**ì„ ë°˜ì˜

### â–¶ í´ë¡(Clock) & í„ìŠ¤(Pulse)
- ë ˆë²¨(level): High/Lowì˜ ì•ˆì • êµ¬ê°„  
- ì—£ì§€(edge): ë ˆë²¨ ë³€í™” ì‹œì  (â†‘/â†“)  
- ë“€í‹°ì‚¬ì´í´: í•œ ì£¼ê¸° ì¤‘ Highì˜ ë¹„ìœ¨

---

## 2. ë˜ì¹˜ì™€ í”Œë¦½í”Œë¡­

### â–¶ ë˜ì¹˜(Latch) vs í”Œë¦½í”Œë¡­(Flip-Flop)
- **ë˜ì¹˜**: ë ˆë²¨ ê°ì§€, ë¹„ë™ê¸°ì‹ (SR, D)  
- **í”Œë¦½í”Œë¡­**: ì—£ì§€ ê°ì§€, ë™ê¸°ì‹ (D, JK ë“±)

### ğŸ’» D Latch
```verilog
module dlatch(input G, input d, output reg q);
  always @(G or d) begin
    if (G) q <= d;
    else   q <= q;
  end
endmodule
```

#### ğŸ§ª D Latch Testbench
```verilog
`timescale 1ns/1ps
module tb_dlatch;
  reg clk, d;
  wire q;
  dlatch U0(.G(clk), .d(d), .q(q));

  initial begin
    clk = 1'b0;
    forever #10 clk = ~clk;
  end

  initial begin
    d = 0;
    #15 d = 1;  #20 d = 0; #10 d = 1; #10 d = 0; #10 d = 1; #15 d = 0;
  end
endmodule
```

### ğŸ’» D Flip-Flop (ì•ˆí‹°íŒ¨í„´ vs ê¶Œì¥)
ì•ˆí‹°íŒ¨í„´: q_barê¹Œì§€ ê°™ì€ `always` ë¸”ë¡ì—ì„œ ê°±ì‹  â†’ **ë¶ˆí•„ìš”í•œ FF ì¦ê°€**
```verilog
module d_ff_bad1(input clk, input d, output reg q, output reg q_bar);
  always @(posedge clk) begin
    q     <= d;
    q_bar <= ~d;
  end
endmodule
```

ê¶Œì¥: `q_bar`ëŠ” `assign`ìœ¼ë¡œ ì™¸ë¶€ì—ì„œ ìƒì„±
```verilog
module d_ff_good(input clk, input d, output reg q, output q_bar);
  assign q_bar = ~q;
  always @(posedge clk) q <= d;
endmodule
```

### ğŸ’» D-FF (ë¹„ë™ê¸° í´ë¦¬ì–´/í”„ë¦¬ì…‹ í¬í•¨) â€“ if + ë…¼ë¸”ë¡í‚¹
```verilog
module d_ff(
  input iCLK, input iCLEARn, input iPRESETn,
  input iD, output reg oQ, output oQn
);
  assign oQn = ~oQ;
  always @(posedge iCLK or negedge iCLEARn or negedge iPRESETn) begin
    if (!iCLEARn)      oQ <= 1'b0;
    else if (!iPRESETn)oQ <= 1'b1;
    else               oQ <= iD;
  end
endmodule
```

#### ğŸ§ª D-FF Testbench
```verilog
`timescale 1ns/1ps
module tb_d_ff;
  reg iCLK, iCLEARn, iPRESETn, iD;
  wire oQ, oQn;

  d_ff U0(.iCLK(iCLK), .iCLEARn(iCLEARn), .iPRESETn(iPRESETn), .iD(iD), .oQ(oQ), .oQn(oQn));

  initial begin
    iCLK = 0;
    forever #50 iCLK = ~iCLK;
  end

  initial begin
    iCLEARn = 1; iPRESETn = 1; iD = 0; #50;
    iCLEARn = 0; #30;                   // clear
    iCLEARn = 1; iPRESETn = 0; #30;     // preset
    iPRESETn = 1; iD = 0; #100;
    iD = 1; #100; iD = 0; #100; iD = 1; #100; iD = 0; #100; 
    $stop;
  end
endmodule
```

### ğŸ’» JK-FF â€“ ê²Œì´íŠ¸ í”„ë¦¬ë¯¸í‹°ë¸Œ ê¸°ë°˜(Dë¡œ êµ¬ì„±)
```verilog
module jk_ff(
  input iCLK, input iCLEARn, input iPRESETn,
  input iJ, input iK, output oQ, output oQn
);
  wire w0, w1, w2, w3;
  not  U0(w0, iK);
  nand U1(w1, oQn, iJ);
  nand U2(w2, w0, oQ);
  nand U3(w3, w1, w2);
  d_ff UDFF(.iCLK(iCLK), .iCLEARn(iCLEARn), .iPRESETn(iPRESETn), .iD(w3), .oQ(oQ), .oQn(oQn));
endmodule
```

### ğŸ’» JK-FF â€“ if + ë…¼ë¸”ë¡í‚¹
```verilog
module jk_ff_bhv(
  input iCLK, input iCLEARn, input iPRESETn,
  input iJ, input iK, output reg oQ, output oQn
);
  assign oQn = ~oQ;
  always @(posedge iCLK or negedge iCLEARn or negedge iPRESETn) begin
    if(!iCLEARn)       oQ <= 1'b0;
    else if(!iPRESETn) oQ <= 1'b1;
    else
      case({iJ,iK})
        2'b00: oQ <= oQ;      // hold
        2'b01: oQ <= 1'b0;    // reset
        2'b10: oQ <= 1'b1;    // set
        2'b11: oQ <= ~oQ;     // toggle
      endcase
  end
endmodule
```

#### ğŸ§ª JK-FF Testbench
```verilog
`timescale 1ns/1ps
module tb_jk_ff;
  reg iCLK, iCLEARn, iPRESETn, iJ, iK;
  wire oQ, oQn;

  jk_ff_bhv U0(.iCLK(iCLK), .iCLEARn(iCLEARn), .iPRESETn(iPRESETn), .iJ(iJ), .iK(iK), .oQ(oQ), .oQn(oQn));

  initial begin
    iCLK = 0; forever #50 iCLK = ~iCLK;
  end

  initial begin
    iCLEARn = 1; iPRESETn = 1; iJ = 0; iK = 0; #50;
    iCLEARn = 0; #30;                       // reset
    iCLEARn = 1; iPRESETn = 0; #30;         // preset
    iPRESETn = 1;
    iJ=0;iK=1; #100;  // reset
    iJ=0;iK=0; #100;  // hold
    iJ=1;iK=0; #100;  // set
    iJ=0;iK=0; #100;  // hold
    iJ=0;iK=1; #100;  // reset
    iJ=0;iK=0; #100;  // hold
    iJ=1;iK=1; #200;  // toggle
    $stop;
  end
endmodule
```

---

## 3. ì‹œí”„íŠ¸ ë ˆì§€ìŠ¤í„°

### â–¶ ê°œìš”
- ì§ë ¬/ë³‘ë ¬ ì…ì¶œë ¥: **SISO, SIPO, PISO, PIPO**  
- ë²„í¼, ì‹œê°„ì§€ì—°, ë˜ë¨¹ì„ êµ¬ì¡° ë“±

### ğŸ’» SIPO â€“ ì¡°ê±´ì—°ì‚°ì
```verilog
module sipo(input iCLK, input iRESETn, input iS, output [3:0] oP);
  reg [3:0] p_out;
  assign oP = p_out;
  always @(posedge iCLK or negedge iRESETn) begin
    if (!iRESETn) p_out <= 4'b0;
    else          p_out <= {p_out[2:0], iS};
  end
endmodule
```

### ğŸ’» SIPO â€“ if
```verilog
module sipo_if(input iCLK, input iRESETn, input iS, output [3:0] oP);
  reg [3:0] p_out; assign oP = p_out;
  always @(posedge iCLK or negedge iRESETn) begin
    if (!iRESETn) p_out <= 4'b0;
    else begin
      p_out <= (p_out << 1);
      p_out[0] <= iS;
    end
  end
endmodule
```

### ğŸ§ª SIPO Testbench
```verilog
`timescale 1ns/10ps
module tb_sipo;
  reg iCLK, iRESETn, iS;
  wire [3:0] oP;
  sipo U0(.iCLK(iCLK), .iRESETn(iRESETn), .iS(iS), .oP(oP));

  initial begin
    iCLK = 0; forever #50 iCLK = ~iCLK;
  end

  initial begin
    iRESETn = 1; iS = 0; #100;
    iRESETn = 0; #30;  // reset
    iRESETn = 1;
    iS=0; #100; iS=0; #100; iS=1; #100; iS=0; #100; iS=0; #100; iS=1; #100;
    $stop;
  end
endmodule
```

### ğŸ’» PISO â€“ ì¡°ê±´ì—°ì‚°ì
```verilog
module piso(input iCLK, input iRESETn, input iLOADn, input [3:0] iP, output oS);
  reg [3:0] q_ff;
  always @(posedge iCLK or negedge iRESETn or negedge iLOADn) begin
    if (!iRESETn)       q_ff <= 4'b0;
    else if (!iLOADn)   q_ff <= iP;
    else                q_ff <= {q_ff[2:0], 1'b0};
  end
  assign oS = q_ff[3];
endmodule
```

### ğŸ’» PISO â€“ if
```verilog
module piso_if(input iCLK, input iRESETn, input iLOADn, input [3:0] iP, output oS);
  reg [3:0] q_ff; assign oS = q_ff[3];
  always @(posedge iCLK or negedge iRESETn or negedge iLOADn) begin
    if (!iRESETn)     q_ff <= 4'b0;
    else if (!iLOADn) q_ff <= iP;
    else begin
      q_ff <= (q_ff << 1);
      q_ff[0] <= 1'b0;
    end
  end
endmodule
```

---

## 4. ì¹´ìš´í„°

### â–¶ ë¶„ë¥˜
- ë™ê¸°/ë¹„ë™ê¸°, 2ì§„/10ì§„, ì¦ê°€/ê°ì†Œ ë“±

### ğŸ’» ë¹„ë™ê¸°ì‹ 4ë¹„íŠ¸ 2ì§„ ì¦ê°€ ì¹´ìš´í„° (Ripple) â€“ í–‰ìœ„ìˆ˜ì¤€
```verilog
module ripple_upcnt(input iCLK, input iRESETn, output [3:0] oQ);
  reg [3:0] qout; assign oQ = qout;
  always @(negedge iCLK or negedge iRESETn) begin
    if (!iRESETn) qout[0] <= 1'b0; else qout[0] <= ~qout[0];
  end
  always @(negedge qout[0] or negedge iRESETn) begin
    if (!iRESETn) qout[1] <= 1'b0; else qout[1] <= ~qout[1];
  end
  always @(negedge qout[1] or negedge iRESETn) begin
    if (!iRESETn) qout[2] <= 1'b0; else qout[2] <= ~qout[2];
  end
  always @(negedge qout[2] or negedge iRESETn) begin
    if (!iRESETn) qout[3] <= 1'b0; else qout[3] <= ~qout[3];
  end
endmodule
```

#### ğŸ§ª Ripple Counter TB
```verilog
`timescale 1ns/10ps
module tb_ripple_upcnt;
  reg iCLK, iRESETn; wire [3:0] oQ;
  ripple_upcnt U0(.iCLK(iCLK), .iRESETn(iRESETn), .oQ(oQ));
  initial iCLK = 0;
  always #50 iCLK = ~iCLK;
  initial begin
    iRESETn = 1; #100; iRESETn = 0; #100; iRESETn = 1; #2000; $stop;
  end
endmodule
```

### ğŸ’» ë™ê¸°ì‹ 4ë¹„íŠ¸ ì¦ê°€/ê°ì†Œ ì¹´ìš´í„° â€“ í–‰ìœ„ìˆ˜ì¤€
```verilog
module sync_cnt(input iCLK, input iRESETn, input iSEL, output [3:0] oQ);
  reg [3:0] qout; assign oQ = qout;
  always @(posedge iCLK or negedge iRESETn) begin
    if (!iRESETn) qout <= 4'b0;
    else case(iSEL)
      1'b0: qout <= qout - 1; // down
      1'b1: qout <= qout + 1; // up
    endcase
  end
endmodule
```

#### ğŸ§ª Sync Counter TB
```verilog
`timescale 1ns/10ps
module tb_sync_cnt;
  reg iCLK, iRESETn, iSEL; wire [3:0] oQ;
  sync_cnt U0(.iCLK(iCLK), .iRESETn(iRESETn), .iSEL(iSEL), .oQ(oQ));
  initial iCLK = 1; always #50 iCLK = ~iCLK;
  initial begin
    iRESETn = 1; iSEL = 1; #60;
    iRESETn = 0; #80;
    iRESETn = 1; iSEL = 1; #1500;
    iSEL = 0; #1500;
    $stop;
  end
endmodule
```

### ğŸ’» BCD(0~9) ì¹´ìš´í„° â€“ í–‰ìœ„ìˆ˜ì¤€
```verilog
module sync_bcd_cnt(input iCLK, input iRESETn, output [3:0] oBCD);
  reg [3:0] bcd; assign oBCD = bcd;
  always @(posedge iCLK or negedge iRESETn) begin
    if (!iRESETn) bcd <= 4'b0;
    else if (bcd < 4'd9) bcd <= bcd + 1;
    else bcd <= 4'd0;
  end
endmodule
```

---

## 5. ì£¼íŒŒìˆ˜ ë¶„ì£¼ê¸°

### ğŸ’» ë¶„ì£¼ê¸° â€“ ì›í•˜ëŠ” ì£¼íŒŒìˆ˜ ìƒì„±
```verilog
module freq_div #(parameter WIDTH=19, parameter VAL_CNT=19'd500000)
 (input iCLK, input iRESETn, output oMYCLK);
  reg [WIDTH-1:0] cnt_clk; reg myclk; assign oMYCLK = myclk;
  always @(posedge iCLK or negedge iRESETn) begin
    if (!iRESETn) begin cnt_clk <= 0; myclk <= 1'b1; end
    else if (cnt_clk == VAL_CNT-1) begin cnt_clk <= 0; myclk <= ~myclk; end
    else cnt_clk <= cnt_clk + 1'b1;
  end
endmodule
```

#### ğŸ§ª ë¶„ì£¼ê¸° TB
```verilog
`timescale 1ns/10ps
module tb_freq_div;
  localparam TCLK = 1000;
  reg iCLK, iRESETn; wire oMYCLK;
  freq_div U0(.iCLK(iCLK), .iRESETn(iRESETn), .oMYCLK(oMYCLK));
  initial begin
    iCLK = 1; iRESETn = 1; #50;
    iRESETn = 0; #30;
    iRESETn = 1; #(TCLK*2000000);
    $stop;
  end
  always #(TCLK/2) iCLK = ~iCLK;
endmodule
```

### ğŸ’» Enable ì‹ í˜¸ ìƒì„±ê¸° (ì˜ˆ: 1Hz/200Hz í„ìŠ¤)
```verilog
module enable_sig #(parameter WIDTH=4, parameter VAL_CNT=10)
 (input iCLK, input iRESETn, output oENSIG);
  reg [WIDTH-1:0] cnt; reg en; assign oENSIG = en;
  always @(posedge iCLK or negedge iRESETn) begin
    if(!iRESETn) begin cnt <= 0; en <= 1'b0; end
    else if (cnt == VAL_CNT-1) begin cnt <= 0; en <= 1'b1; end
    else begin cnt <= cnt + 1'b1; en <= 1'b0; end
  end
endmodule
```

---

## 6. 7-ì„¸ê·¸ë¨¼íŠ¸ ë””ì½”ë”

### ğŸ’» ë‹¨ì¼ ìë¦¬ CCí˜• ë””ì½”ë”
```verilog
module fnd_decoder_cc(input [3:0] iBCD, output reg [7:0] oDATA_FND);
  // abcd_efgdp (0ì´ë©´ LED ON) â€“ CCí˜•
  always @* begin
    case (iBCD)
      4'd0: oDATA_FND = 8'b1111_1100;
      4'd1: oDATA_FND = 8'b0110_0000;
      4'd2: oDATA_FND = 8'b1101_1010;
      4'd3: oDATA_FND = 8'b1111_0010;
      4'd4: oDATA_FND = 8'b0110_0110;
      4'd5: oDATA_FND = 8'b1011_0110;
      4'd6: oDATA_FND = 8'b1011_1110;
      4'd7: oDATA_FND = 8'b1110_0100;
      4'd8: oDATA_FND = 8'b1111_1110;
      4'd9: oDATA_FND = 8'b1110_0110;
      default: oDATA_FND = 8'b1111_1111;
    endcase
  end
endmodule
```

### ğŸ’» 4ìë¦¬ CCí˜• ë“œë¼ì´ë²„ (200Hz ë‹¤ì¤‘í™”)
```verilog
module drv_fnd4(input iCLK, input iRESETn, input iEN_200,
                input [15:0] iBCD, output [3:0] oCOM_FND, output [7:0] oDATA_FND);
  reg [1:0] sel;
  reg [3:0] bcd;
  reg [3:0] com;
  wire [7:0] data;

  always @(posedge iCLK or negedge iRESETn) begin
    if (!iRESETn) sel <= 2'b00;
    else if (iEN_200) sel <= sel + 2'b01;
  end

  always @* begin
    case (sel)
      2'd0: begin com = 4'b1110; bcd = iBCD[3:0];   end
      2'd1: begin com = 4'b1101; bcd = iBCD[7:4];   end
      2'd2: begin com = 4'b1011; bcd = iBCD[11:8];  end
      2'd3: begin com = 4'b0117; bcd = iBCD[15:12]; end
    endcase
  end

  fnd_decoder_cc DEC(.iBCD(bcd), .oDATA_FND(data));

  assign oCOM_FND  = com;
  assign oDATA_FND = data;
endmodule
```

---

## 7. ìœ í•œìƒíƒœë¨¸ì‹ (FSM)

### â–¶ ê°œë… ìš”ì•½
- **FSM**: ìœ í•œ ê°œìˆ˜ì˜ ìƒíƒœ(State)ì™€ ì…ë ¥(Input)ì— ë”°ë¼ **í´ë¡ ì´ë²¤íŠ¸**ë§ˆë‹¤ ìƒíƒœê°€ ì „ì´(Transition)í•˜ë©°, ê·¸ì— ë”°ë¥¸ **ì¶œë ¥(Output)** ì„ ìƒì„±í•˜ëŠ” ìˆœì°¨íšŒë¡œ ëª¨ë¸.
- **Moore**: ì¶œë ¥ì€ **í˜„ì¬ ìƒíƒœ**ë§Œì˜ í•¨ìˆ˜ â†’ íƒ€ì´ë° ì˜ˆì¸¡ ì‰¬ì›€, ê¸€ë¦¬ì¹˜ ì ìŒ.
- **Mealy**: ì¶œë ¥ì€ **í˜„ì¬ ìƒíƒœ + ì…ë ¥**ì˜ í•¨ìˆ˜ â†’ ìƒíƒœ ìˆ˜ê°€ ì¤„ì–´ë“œëŠ” ê²½í–¥, ë°˜ì‘ ë¹ ë¦„.

### â–¶ ìƒíƒœ ì¸ì½”ë”© (Encoding)
- **Binary(Compact)**: ìƒíƒœ ìˆ˜ ì ì„ ë•Œ LUT/FF ìì› ì ˆì•½.
- **One-Hot**: ìƒíƒœ ìˆ˜ ë§ì„ ë•Œ ë¹ ë¥´ê³  íƒ€ì´ë° ìœ ë¦¬(Vivado ê¸°ë³¸ ìµœì í™” ëŒ€ìƒ).
- **Gray**: ì¸ì ‘ ìƒíƒœ í•œ ë¹„íŠ¸ë§Œ ë³€í™” â†’ ê¸€ë¦¬ì¹˜ ë¯¼ê° ê²½ë¡œì— ìœ ë¦¬.

> Vivadoì—ì„œ ì¸ì½”ë”© ì§€ì‹œ(ì˜µì…˜):  
> `(* fsm_encoding = "one-hot" *)` / `"sequential"` / `"gray"`

---

### â–¶ ì½”ë”© í…œí”Œë¦¿(ê¶Œì¥ íŒ¨í„´)

#### (A) 3-ë¸”ë¡ íŒŒí˜• (ê°€ì¥ êµê³¼ì„œì )
1) **ìƒíƒœ ë ˆì§€ìŠ¤í„°** : í´ë¡/ë¦¬ì…‹ì—ì„œ í˜„ì¬ ìƒíƒœ ê°±ì‹   
2) **ë‹¤ìŒ ìƒíƒœ ì¡°í•© ë…¼ë¦¬** : `cs`ì™€ ì…ë ¥ìœ¼ë¡œ `ns` ì‚°ì¶œ  
3) **ì¶œë ¥ ì¡°í•© ë…¼ë¦¬** : Moore/Mealy ë°©ì‹ì— ë§ì¶° ì¶œë ¥ ì‚°ì¶œ

```verilog
module fsm_template #(
  parameter USE_ONEHOT = 0
)(
  input  wire iCLK, iRESETn,
  input  wire x,
  output reg  y
);
  // 1) ìƒíƒœ ì„ ì–¸
  typedef enum reg [ (USE_ONEHOT?3:1) :0 ] {
    S0 = (USE_ONEHOT?4'b0001:2'd0),
    S1 = (USE_ONEHOT?4'b0010:2'd1),
    S2 = (USE_ONEHOT?4'b0100:2'd2),
    S3 = (USE_ONEHOT?4'b1000:2'd3)
  } state_t;

  state_t cs, ns;

  // 2) ìƒíƒœ ë ˆì§€ìŠ¤í„°
  always @(posedge iCLK or negedge iRESETn) begin
    if(!iRESETn) cs <= S0;
    else         cs <= ns;
  end

  // 3) ë‹¤ìŒ ìƒíƒœ ì¡°í•© ë…¼ë¦¬
  always @* begin
    ns = cs;
    case (cs)
      S0: ns = x ? S1 : S0;
      S1: ns = x ? S2 : S0;
      S2: ns = x ? S3 : S1;
      S3: ns = x ? S3 : S2;
      default: ns = S0;
    endcase
  end

  // 4) ì¶œë ¥ ì¡°í•© ë…¼ë¦¬(Moore ì˜ˆì‹œ)
  always @* begin
    case (cs)
      S3:     y = 1'b1;
      default:y = 1'b0;
    endcase
  end
endmodule
```

---

### â–¶ ì„¤ê³„ ì²´í¬ë¦¬ìŠ¤íŠ¸
- **ë¦¬ì…‹**: ë¹„ë™ê¸° ë¦¬ì…‹ ì‹œ ë¯¼ê°ë„ ëª©ë¡ì— `negedge iRESETn` í¬í•¨.  
- **ê¸°ë³¸ê°’**: ì¡°í•© always ë¸”ë¡ ì‹œì‘ ì‹œ `ns=cs;` / ì¶œë ¥ ê¸°ë³¸ê°’ ì„¤ì • â†’ **ë˜ì¹˜ ë°©ì§€**.  
- **Mealy ì¶œë ¥ ê¸€ë¦¬ì¹˜**: ê°€ëŠ¥í•˜ë©´ í•œ í´ë¡ ì§€ì—°(ë ˆì§€ìŠ¤í„° ì¶œë ¥)ìœ¼ë¡œ ì•ˆì •í™”.  
- **CDC**: ë‹¤ë¥¸ í´ë¡ ë„ë©”ì¸ì˜ ì…ë ¥ì€ **2-FF ë™ê¸°í™”** í›„ FSMì— ì¸ê°€.  
- **íƒ€ì´ë° ì—¬ìœ **: One-hot ì¸ì½”ë”© ê³ ë ¤, ë¶ˆí•„ìš”í•œ ê¸´ ì¡°í•©ê²½ë¡œ í”¼í•˜ê¸°.  

---

## 7.1 Moore FSM ì˜ˆì œ â€“ ì‹œí€€ìŠ¤ ë””í…í„°(1011, ì¤‘ì²© í—ˆìš©)
```verilog
module seqdet_moore_1011 (
  input  wire iCLK, input wire iRESETn,
  input  wire x,
  output reg  y
);
  typedef enum reg [2:0] {S0, S1, S10, S101, S1011} state_t;
  state_t cs, ns;

  // ìƒíƒœ ë ˆì§€ìŠ¤í„°
  always @(posedge iCLK or negedge iRESETn) begin
    if(!iRESETn) cs <= S0;
    else         cs <= ns;
  end

  // ë‹¤ìŒ ìƒíƒœ ì¡°í•© ë…¼ë¦¬
  always @* begin
    ns = cs;
    case (cs)
      S0   : ns = x ? S1   : S0;
      S1   : ns = x ? S1   : S10;   // '1' ìœ ì§€ or '10'
      S10  : ns = x ? S101 : S0;    // '101' or ë¦¬ì…‹
      S101 : ns = x ? S1011: S10;   // '1011' or '10'
      S1011: ns = x ? S1   : S10;   // overlapping ì²˜ë¦¬
      default: ns = S0;
    endcase
  end

  // ì¶œë ¥(Moore): ìƒíƒœë§Œì˜ í•¨ìˆ˜
  always @* begin
    y = (cs == S1011);
  end
endmodule
```

**Testbench**
```verilog
`timescale 1ns/1ps
module tb_seqdet_moore_1011;
  reg clk, rstn, x; wire y;
  seqdet_moore_1011 DUT(.iCLK(clk), .iRESETn(rstn), .x(x), .y(y));
  initial begin clk=0; forever #5 clk=~clk; end
  task APPLY(input [31:0] bits, input integer n);
    integer i;
    begin
      for(i=n-1;i>=0;i=i-1) begin x = bits[i]; @(posedge clk); end
    end
  endtask
  initial begin
    rstn=0; x=0; repeat(2) @(posedge clk); rstn=1;
    // ...1011... íŒ¨í„´ ë‘ ë²ˆ í¬í•¨
    APPLY(32'b1_0_1_1_1_0_1_1, 8);
    repeat(10) @(posedge clk);
    $stop;
  end
endmodule
```

---

## 7.2 Mealy FSM ì˜ˆì œ â€“ ì‹œí€€ìŠ¤ ë””í…í„°(1011, ë¹„ì¤‘ì²©)
```verilog
module seqdet_mealy_1011_nolap (
  input  wire iCLK, input wire iRESETn,
  input  wire x,
  output reg  y
);
  typedef enum reg [1:0] {S0, S1, S10, S101} state_t;
  state_t cs, ns;

  always @(posedge iCLK or negedge iRESETn) begin
    if(!iRESETn) cs <= S0;
    else         cs <= ns;
  end

  // Mealy: ì¶œë ¥ì´ ì…ë ¥ê³¼ ìƒíƒœì˜ í•¨ìˆ˜ â†’ ì¡°í•©ì—ì„œ ì‚°ì¶œ (ê¸€ë¦¬ì¹˜ ì£¼ì˜)
  always @* begin
    // ê¸°ë³¸ê°’
    ns = cs;
    y  = 1'b0;

    case (cs)
      S0  : begin
              ns = x ? S1 : S0;
            end
      S1  : begin
              ns = x ? S1 : S10;
            end
      S10 : begin
              ns = x ? S101 : S0;
            end
      S101: begin
              if (x) begin
                y  = 1'b1;   // íŒ¨í„´ 1011 ì™„ì„± ì‹œ ê°™ì€ í´ë¡ì— 1
                ns = S0;     // ë¹„ì¤‘ì²©: ì´ˆê¸°í™”
              end else begin
                ns = S10;
              end
            end
      default: ns = S0;
    endcase
  end
endmodule
```

> **ê¸€ë¦¬ì¹˜ ë°©ì§€ íŒ**: `y`ë¥¼ í•œ í´ë¡ ë ˆì§€ìŠ¤í„°ì— ì €ì¥í•´ ì¶œë ¥í•˜ë©´ íŒŒí˜• ì•ˆì •.

---

## 7.3 íƒ€ì´ë¨¸ ê¸°ë°˜ ì‹ í˜¸ë“± ì»¨íŠ¸ë¡¤ëŸ¬ (Moore + Enable íƒ€ì´ë¨¸)
```verilog
module traffic_light (
  input  wire iCLK, input wire iRESETn,
  input  wire en_1hz,                 // 1Hz enable pulse
  output reg  [2:0] NS,               // {R,Y,G}
  output reg  [2:0] EW
);
  typedef enum reg [1:0] {NS_G, NS_Y, EW_G, EW_Y} state_t;
  state_t cs, ns;
  reg [2:0] tcnt; // ì´ˆ ì¹´ìš´í„°(ìµœëŒ€ 3)

  // ìƒíƒœ ë ˆì§€ìŠ¤í„° & ì´ˆ ì¹´ìš´í„°
  always @(posedge iCLK or negedge iRESETn) begin
    if(!iRESETn) begin cs <= NS_G; tcnt <= 0; end
    else begin
      cs <= ns;
      if(en_1hz) begin
        case (cs)
          NS_G, EW_G: tcnt <= (tcnt==3-1) ? 0 : tcnt + 1;  // 3ì´ˆ
          NS_Y, EW_Y: tcnt <= (tcnt==1-1) ? 0 : tcnt + 1;  // 1ì´ˆ
          default:    tcnt <= 0;
        endcase
      end
    end
  end

  // ë‹¤ìŒ ìƒíƒœ ì¡°í•© ë…¼ë¦¬
  always @* begin
    ns = cs;
    case (cs)
      NS_G : ns = (tcnt==3-1 && en_1hz) ? NS_Y : NS_G;
      NS_Y : ns = (tcnt==1-1 && en_1hz) ? EW_G : NS_Y;
      EW_G : ns = (tcnt==3-1 && en_1hz) ? EW_Y : EW_G;
      EW_Y : ns = (tcnt==1-1 && en_1hz) ? NS_G : EW_Y;
      default: ns = NS_G;
    endcase
  end

  // ì¶œë ¥(Moore) â€“ ìƒíƒœë§Œì˜ í•¨ìˆ˜
  always @* begin
    case (cs)
      NS_G: begin NS=3'b001; EW=3'b100; end  // NS:G, EW:R
      NS_Y: begin NS=3'b010; EW=3'b100; end  // NS:Y, EW:R
      EW_G: begin NS=3'b100; EW=3'b001; end  // NS:R, EW:G
      EW_Y: begin NS=3'b100; EW=3'b010; end  // NS:R, EW:Y
      default: begin NS=3'b100; EW=3'b100; end
    endcase
  end
endmodule
```

**1Hz Enable ìƒì„±ê¸°(ì˜ˆ: 50 MHz â†’ 1 Hz)**
```verilog
module en1hz #(parameter CLK=50_000_000) (
  input iCLK, input iRESETn, output reg oEN
);
  localparam DIV = CLK-1;
  reg [$clog2(CLK)-1:0] cnt;
  always @(posedge iCLK or negedge iRESETn) begin
    if(!iRESETn) begin cnt<=0; oEN<=1'b0; end
    else if(cnt==DIV) begin cnt<=0; oEN<=1'b1; end
    else begin cnt<=cnt+1'b1; oEN<=1'b0; end
  end
endmodule
```

**Testbench(ê°„ë‹¨)**
```verilog
`timescale 1ns/1ps
module tb_traffic_light;
  reg clk, rstn; wire en1; wire [2:0] NS, EW;
  en1hz #(.CLK(1_000_000)) EN(.iCLK(clk), .iRESETn(rstn), .oEN(en1)); // TB ê°€ì†ìš© 1MHzâ†’1Hz
  traffic_light DUT(.iCLK(clk), .iRESETn(rstn), .en_1hz(en1), .NS(NS), .EW(EW));
  initial begin clk=0; forever #0.5 clk=~clk; end // 1MHz
  initial begin
    rstn=0; repeat(5) @(posedge clk); rstn=1;
    repeat(20) @(posedge clk); // ìˆ˜ ì´ˆ ê´€ì°°
    $stop;
  end
endmodule
```

---

### â–¶ Mealy vs Moore ì„ íƒ ê°€ì´ë“œ
- **ì†ë„ ìš°ì„  / ìƒíƒœ ìˆ˜ ìµœì†Œ**: Mealy  
- **ì¶œë ¥ ì•ˆì •ì„± / íƒ€ì´ë° ì˜ˆì¸¡**: Moore  
- **ì‹¤ë¬´ íŒ**: Mealyë¼ë„ ë§ˆì§€ë§‰ì— **ë ˆì§€ìŠ¤í„° 1ë‹¨**ì„ í†µê³¼ì‹œì¼œ **ê¸€ë¦¬ì¹˜ ì–µì œ** â†’ Mooreì™€ ìœ ì‚¬í•œ ì•ˆì •ì„± í™•ë³´

---

### âœ… ìš”ì•½ ì²´í¬ë¦¬ìŠ¤íŠ¸
- `ns=cs;` / `y=ê¸°ë³¸ê°’;`ë¡œ ì‹œì‘í•˜ëŠ” ì¡°í•© ë¸”ë¡ â†’ ë˜ì¹˜ ë°©ì§€  
- ë¹„ë™ê¸° ë¦¬ì…‹ ì‹œ **ë¯¼ê°ë„ ëª©ë¡**ê³¼ **ë¦¬ì…‹ í›„ ì´ˆê¸° ìƒíƒœ** ëª…í™•í™”  
- Mealy ì¶œë ¥ì€ ê°€ëŠ¥í•˜ë©´ **ë ˆì§€ìŠ¤í„°ë§**  
- ìƒíƒœ ì¸ì½”ë”©ì€ íƒ€ì´ë°/ìì›ì— ë§ê²Œ **one-hot/compact** ì„ íƒ  
- ì™¸ë¶€ ë¹„ë™ê¸° ì…ë ¥ì€ **2-FF ë™ê¸°í™”** í›„ FSMì— íˆ¬ì…
