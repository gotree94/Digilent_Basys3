# 🧩 Digilent Basys3 Verilog 순차회로 모델링

## 🎯 학습목표
- 모델링의 기본 단위인 **모듈**을 이해한다.  
- 대표적인 **순차회로**를 모델링할 수 있다.  
- **유한상태머신(FSM)** 의 개념을 이해한다.  
- **Mealy FSM** 과 **Moore FSM** 의 차이를 이해한다.  
- Mealy/Moore FSM을 **Verilog**로 모델링할 수 있다.  

---

## 📚 목차
1. [순차회로 개요](#1-순차회로combinational-circuit)
2. [래치와 플립플롭](#2-래치와-플립플롭)
3. [시프트 레지스터](#3-시프트-레지스터)
4. [카운터](#4-카운터)
5. [주파수 분주기](#5-주파수-분주기)
6. [7-세그먼트 디코더/드라이버](#6-7-세그먼트-디코더)
7. [유한상태머신(FSM)](#7-유한상태머신fsm)

---

## 1. 순차회로(Combinational circuit)

### ▶ 순차회로
- 시간의 흐름에 따라 **상태(state)** 가 변함  
- 상태는 **과거 상태 + 현재 입력**의 조합으로 결정  
- **기억소자 O** (상태 레지스터, 카운터, 타이머)

### ▶ 동기식 순차회로
- **클록의 엣지**에서만 상태 전이  
- 명확한 시간 간격에 따라 출력이 변함

### ▶ 비동기식 순차회로
- 클록과 무관하게 **임의 시점의 입력**을 반영

### ▶ 클록(Clock) & 펄스(Pulse)
- 레벨(level): High/Low의 안정 구간  
- 엣지(edge): 레벨 변화 시점 (↑/↓)  
- 듀티사이클: 한 주기 중 High의 비율

---

## 2. 래치와 플립플롭

### ▶ 래치(Latch) vs 플립플롭(Flip-Flop)
- **래치**: 레벨 감지, 비동기식 (SR, D)  
- **플립플롭**: 엣지 감지, 동기식 (D, JK 등)

### 💻 D Latch
```verilog
module dlatch(input G, input d, output reg q);
  always @(G or d) begin
    if (G) q <= d;
    else   q <= q;
  end
endmodule
```

#### 🧪 D Latch Testbench
```verilog
`timescale 1ns/1ps
module tb_dlatch;
  reg clk, d;
  wire q;
  dlatch U0(.G(clk), .d(d), .q(q));

  initial begin
    clk = 1'b0;
    forever #10 clk = ~clk;
  end

  initial begin
    d = 0;
    #15 d = 1;  #20 d = 0; #10 d = 1; #10 d = 0; #10 d = 1; #15 d = 0;
  end
endmodule
```

### 💻 D Flip-Flop (안티패턴 vs 권장)
안티패턴: q_bar까지 같은 `always` 블록에서 갱신 → **불필요한 FF 증가**
```verilog
module d_ff_bad1(input clk, input d, output reg q, output reg q_bar);
  always @(posedge clk) begin
    q     <= d;
    q_bar <= ~d;
  end
endmodule
```

권장: `q_bar`는 `assign`으로 외부에서 생성
```verilog
module d_ff_good(input clk, input d, output reg q, output q_bar);
  assign q_bar = ~q;
  always @(posedge clk) q <= d;
endmodule
```

### 💻 D-FF (비동기 클리어/프리셋 포함) – if + 논블록킹
```verilog
module d_ff(
  input iCLK, input iCLEARn, input iPRESETn,
  input iD, output reg oQ, output oQn
);
  assign oQn = ~oQ;
  always @(posedge iCLK or negedge iCLEARn or negedge iPRESETn) begin
    if (!iCLEARn)      oQ <= 1'b0;
    else if (!iPRESETn)oQ <= 1'b1;
    else               oQ <= iD;
  end
endmodule
```

#### 🧪 D-FF Testbench
```verilog
`timescale 1ns/1ps
module tb_d_ff;
  reg iCLK, iCLEARn, iPRESETn, iD;
  wire oQ, oQn;

  d_ff U0(.iCLK(iCLK), .iCLEARn(iCLEARn), .iPRESETn(iPRESETn), .iD(iD), .oQ(oQ), .oQn(oQn));

  initial begin
    iCLK = 0;
    forever #50 iCLK = ~iCLK;
  end

  initial begin
    iCLEARn = 1; iPRESETn = 1; iD = 0; #50;
    iCLEARn = 0; #30;                   // clear
    iCLEARn = 1; iPRESETn = 0; #30;     // preset
    iPRESETn = 1; iD = 0; #100;
    iD = 1; #100; iD = 0; #100; iD = 1; #100; iD = 0; #100; 
    $stop;
  end
endmodule
```

### 💻 JK-FF – 게이트 프리미티브 기반(D로 구성)
```verilog
module jk_ff(
  input iCLK, input iCLEARn, input iPRESETn,
  input iJ, input iK, output oQ, output oQn
);
  wire w0, w1, w2, w3;
  not  U0(w0, iK);
  nand U1(w1, oQn, iJ);
  nand U2(w2, w0, oQ);
  nand U3(w3, w1, w2);
  d_ff UDFF(.iCLK(iCLK), .iCLEARn(iCLEARn), .iPRESETn(iPRESETn), .iD(w3), .oQ(oQ), .oQn(oQn));
endmodule
```

### 💻 JK-FF – if + 논블록킹
```verilog
module jk_ff_bhv(
  input iCLK, input iCLEARn, input iPRESETn,
  input iJ, input iK, output reg oQ, output oQn
);
  assign oQn = ~oQ;
  always @(posedge iCLK or negedge iCLEARn or negedge iPRESETn) begin
    if(!iCLEARn)       oQ <= 1'b0;
    else if(!iPRESETn) oQ <= 1'b1;
    else
      case({iJ,iK})
        2'b00: oQ <= oQ;      // hold
        2'b01: oQ <= 1'b0;    // reset
        2'b10: oQ <= 1'b1;    // set
        2'b11: oQ <= ~oQ;     // toggle
      endcase
  end
endmodule
```

#### 🧪 JK-FF Testbench
```verilog
`timescale 1ns/1ps
module tb_jk_ff;
  reg iCLK, iCLEARn, iPRESETn, iJ, iK;
  wire oQ, oQn;

  jk_ff_bhv U0(.iCLK(iCLK), .iCLEARn(iCLEARn), .iPRESETn(iPRESETn), .iJ(iJ), .iK(iK), .oQ(oQ), .oQn(oQn));

  initial begin
    iCLK = 0; forever #50 iCLK = ~iCLK;
  end

  initial begin
    iCLEARn = 1; iPRESETn = 1; iJ = 0; iK = 0; #50;
    iCLEARn = 0; #30;                       // reset
    iCLEARn = 1; iPRESETn = 0; #30;         // preset
    iPRESETn = 1;
    iJ=0;iK=1; #100;  // reset
    iJ=0;iK=0; #100;  // hold
    iJ=1;iK=0; #100;  // set
    iJ=0;iK=0; #100;  // hold
    iJ=0;iK=1; #100;  // reset
    iJ=0;iK=0; #100;  // hold
    iJ=1;iK=1; #200;  // toggle
    $stop;
  end
endmodule
```

---

## 3. 시프트 레지스터

### ▶ 개요
- 직렬/병렬 입출력: **SISO, SIPO, PISO, PIPO**  
- 버퍼, 시간지연, 되먹임 구조 등

### 💻 SIPO – 조건연산자
```verilog
module sipo(input iCLK, input iRESETn, input iS, output [3:0] oP);
  reg [3:0] p_out;
  assign oP = p_out;
  always @(posedge iCLK or negedge iRESETn) begin
    if (!iRESETn) p_out <= 4'b0;
    else          p_out <= {p_out[2:0], iS};
  end
endmodule
```

### 💻 SIPO – if
```verilog
module sipo_if(input iCLK, input iRESETn, input iS, output [3:0] oP);
  reg [3:0] p_out; assign oP = p_out;
  always @(posedge iCLK or negedge iRESETn) begin
    if (!iRESETn) p_out <= 4'b0;
    else begin
      p_out <= (p_out << 1);
      p_out[0] <= iS;
    end
  end
endmodule
```

### 🧪 SIPO Testbench
```verilog
`timescale 1ns/10ps
module tb_sipo;
  reg iCLK, iRESETn, iS;
  wire [3:0] oP;
  sipo U0(.iCLK(iCLK), .iRESETn(iRESETn), .iS(iS), .oP(oP));

  initial begin
    iCLK = 0; forever #50 iCLK = ~iCLK;
  end

  initial begin
    iRESETn = 1; iS = 0; #100;
    iRESETn = 0; #30;  // reset
    iRESETn = 1;
    iS=0; #100; iS=0; #100; iS=1; #100; iS=0; #100; iS=0; #100; iS=1; #100;
    $stop;
  end
endmodule
```

### 💻 PISO – 조건연산자
```verilog
module piso(input iCLK, input iRESETn, input iLOADn, input [3:0] iP, output oS);
  reg [3:0] q_ff;
  always @(posedge iCLK or negedge iRESETn or negedge iLOADn) begin
    if (!iRESETn)       q_ff <= 4'b0;
    else if (!iLOADn)   q_ff <= iP;
    else                q_ff <= {q_ff[2:0], 1'b0};
  end
  assign oS = q_ff[3];
endmodule
```

### 💻 PISO – if
```verilog
module piso_if(input iCLK, input iRESETn, input iLOADn, input [3:0] iP, output oS);
  reg [3:0] q_ff; assign oS = q_ff[3];
  always @(posedge iCLK or negedge iRESETn or negedge iLOADn) begin
    if (!iRESETn)     q_ff <= 4'b0;
    else if (!iLOADn) q_ff <= iP;
    else begin
      q_ff <= (q_ff << 1);
      q_ff[0] <= 1'b0;
    end
  end
endmodule
```

---

## 4. 카운터

### ▶ 분류
- 동기/비동기, 2진/10진, 증가/감소 등

### 💻 비동기식 4비트 2진 증가 카운터 (Ripple) – 행위수준
```verilog
module ripple_upcnt(input iCLK, input iRESETn, output [3:0] oQ);
  reg [3:0] qout; assign oQ = qout;
  always @(negedge iCLK or negedge iRESETn) begin
    if (!iRESETn) qout[0] <= 1'b0; else qout[0] <= ~qout[0];
  end
  always @(negedge qout[0] or negedge iRESETn) begin
    if (!iRESETn) qout[1] <= 1'b0; else qout[1] <= ~qout[1];
  end
  always @(negedge qout[1] or negedge iRESETn) begin
    if (!iRESETn) qout[2] <= 1'b0; else qout[2] <= ~qout[2];
  end
  always @(negedge qout[2] or negedge iRESETn) begin
    if (!iRESETn) qout[3] <= 1'b0; else qout[3] <= ~qout[3];
  end
endmodule
```

#### 🧪 Ripple Counter TB
```verilog
`timescale 1ns/10ps
module tb_ripple_upcnt;
  reg iCLK, iRESETn; wire [3:0] oQ;
  ripple_upcnt U0(.iCLK(iCLK), .iRESETn(iRESETn), .oQ(oQ));
  initial iCLK = 0;
  always #50 iCLK = ~iCLK;
  initial begin
    iRESETn = 1; #100; iRESETn = 0; #100; iRESETn = 1; #2000; $stop;
  end
endmodule
```

### 💻 동기식 4비트 증가/감소 카운터 – 행위수준
```verilog
module sync_cnt(input iCLK, input iRESETn, input iSEL, output [3:0] oQ);
  reg [3:0] qout; assign oQ = qout;
  always @(posedge iCLK or negedge iRESETn) begin
    if (!iRESETn) qout <= 4'b0;
    else case(iSEL)
      1'b0: qout <= qout - 1; // down
      1'b1: qout <= qout + 1; // up
    endcase
  end
endmodule
```

#### 🧪 Sync Counter TB
```verilog
`timescale 1ns/10ps
module tb_sync_cnt;
  reg iCLK, iRESETn, iSEL; wire [3:0] oQ;
  sync_cnt U0(.iCLK(iCLK), .iRESETn(iRESETn), .iSEL(iSEL), .oQ(oQ));
  initial iCLK = 1; always #50 iCLK = ~iCLK;
  initial begin
    iRESETn = 1; iSEL = 1; #60;
    iRESETn = 0; #80;
    iRESETn = 1; iSEL = 1; #1500;
    iSEL = 0; #1500;
    $stop;
  end
endmodule
```

### 💻 BCD(0~9) 카운터 – 행위수준
```verilog
module sync_bcd_cnt(input iCLK, input iRESETn, output [3:0] oBCD);
  reg [3:0] bcd; assign oBCD = bcd;
  always @(posedge iCLK or negedge iRESETn) begin
    if (!iRESETn) bcd <= 4'b0;
    else if (bcd < 4'd9) bcd <= bcd + 1;
    else bcd <= 4'd0;
  end
endmodule
```

---

## 5. 주파수 분주기

### 💻 분주기 – 원하는 주파수 생성
```verilog
module freq_div #(parameter WIDTH=19, parameter VAL_CNT=19'd500000)
 (input iCLK, input iRESETn, output oMYCLK);
  reg [WIDTH-1:0] cnt_clk; reg myclk; assign oMYCLK = myclk;
  always @(posedge iCLK or negedge iRESETn) begin
    if (!iRESETn) begin cnt_clk <= 0; myclk <= 1'b1; end
    else if (cnt_clk == VAL_CNT-1) begin cnt_clk <= 0; myclk <= ~myclk; end
    else cnt_clk <= cnt_clk + 1'b1;
  end
endmodule
```

#### 🧪 분주기 TB
```verilog
`timescale 1ns/10ps
module tb_freq_div;
  localparam TCLK = 1000;
  reg iCLK, iRESETn; wire oMYCLK;
  freq_div U0(.iCLK(iCLK), .iRESETn(iRESETn), .oMYCLK(oMYCLK));
  initial begin
    iCLK = 1; iRESETn = 1; #50;
    iRESETn = 0; #30;
    iRESETn = 1; #(TCLK*2000000);
    $stop;
  end
  always #(TCLK/2) iCLK = ~iCLK;
endmodule
```

### 💻 Enable 신호 생성기 (예: 1Hz/200Hz 펄스)
```verilog
module enable_sig #(parameter WIDTH=4, parameter VAL_CNT=10)
 (input iCLK, input iRESETn, output oENSIG);
  reg [WIDTH-1:0] cnt; reg en; assign oENSIG = en;
  always @(posedge iCLK or negedge iRESETn) begin
    if(!iRESETn) begin cnt <= 0; en <= 1'b0; end
    else if (cnt == VAL_CNT-1) begin cnt <= 0; en <= 1'b1; end
    else begin cnt <= cnt + 1'b1; en <= 1'b0; end
  end
endmodule
```

---

## 6. 7-세그먼트 디코더

### 💻 단일 자리 CC형 디코더
```verilog
module fnd_decoder_cc(input [3:0] iBCD, output reg [7:0] oDATA_FND);
  // abcd_efgdp (0이면 LED ON) – CC형
  always @* begin
    case (iBCD)
      4'd0: oDATA_FND = 8'b1111_1100;
      4'd1: oDATA_FND = 8'b0110_0000;
      4'd2: oDATA_FND = 8'b1101_1010;
      4'd3: oDATA_FND = 8'b1111_0010;
      4'd4: oDATA_FND = 8'b0110_0110;
      4'd5: oDATA_FND = 8'b1011_0110;
      4'd6: oDATA_FND = 8'b1011_1110;
      4'd7: oDATA_FND = 8'b1110_0100;
      4'd8: oDATA_FND = 8'b1111_1110;
      4'd9: oDATA_FND = 8'b1110_0110;
      default: oDATA_FND = 8'b1111_1111;
    endcase
  end
endmodule
```

### 💻 4자리 CC형 드라이버 (200Hz 다중화)
```verilog
module drv_fnd4(input iCLK, input iRESETn, input iEN_200,
                input [15:0] iBCD, output [3:0] oCOM_FND, output [7:0] oDATA_FND);
  reg [1:0] sel;
  reg [3:0] bcd;
  reg [3:0] com;
  wire [7:0] data;

  always @(posedge iCLK or negedge iRESETn) begin
    if (!iRESETn) sel <= 2'b00;
    else if (iEN_200) sel <= sel + 2'b01;
  end

  always @* begin
    case (sel)
      2'd0: begin com = 4'b1110; bcd = iBCD[3:0];   end
      2'd1: begin com = 4'b1101; bcd = iBCD[7:4];   end
      2'd2: begin com = 4'b1011; bcd = iBCD[11:8];  end
      2'd3: begin com = 4'b0117; bcd = iBCD[15:12]; end
    endcase
  end

  fnd_decoder_cc DEC(.iBCD(bcd), .oDATA_FND(data));

  assign oCOM_FND  = com;
  assign oDATA_FND = data;
endmodule
```

---

## 7. 유한상태머신(FSM)

### ▶ 개념 요약
- **FSM**: 유한 개수의 상태(State)와 입력(Input)에 따라 **클록 이벤트**마다 상태가 전이(Transition)하며, 그에 따른 **출력(Output)** 을 생성하는 순차회로 모델.
- **Moore**: 출력은 **현재 상태**만의 함수 → 타이밍 예측 쉬움, 글리치 적음.
- **Mealy**: 출력은 **현재 상태 + 입력**의 함수 → 상태 수가 줄어드는 경향, 반응 빠름.

### ▶ 상태 인코딩 (Encoding)
- **Binary(Compact)**: 상태 수 적을 때 LUT/FF 자원 절약.
- **One-Hot**: 상태 수 많을 때 빠르고 타이밍 유리(Vivado 기본 최적화 대상).
- **Gray**: 인접 상태 한 비트만 변화 → 글리치 민감 경로에 유리.

> Vivado에서 인코딩 지시(옵션):  
> `(* fsm_encoding = "one-hot" *)` / `"sequential"` / `"gray"`

---

### ▶ 코딩 템플릿(권장 패턴)

#### (A) 3-블록 파형 (가장 교과서적)
1) **상태 레지스터** : 클록/리셋에서 현재 상태 갱신  
2) **다음 상태 조합 논리** : `cs`와 입력으로 `ns` 산출  
3) **출력 조합 논리** : Moore/Mealy 방식에 맞춰 출력 산출

```verilog
module fsm_template #(
  parameter USE_ONEHOT = 0
)(
  input  wire iCLK, iRESETn,
  input  wire x,
  output reg  y
);
  // 1) 상태 선언
  typedef enum reg [ (USE_ONEHOT?3:1) :0 ] {
    S0 = (USE_ONEHOT?4'b0001:2'd0),
    S1 = (USE_ONEHOT?4'b0010:2'd1),
    S2 = (USE_ONEHOT?4'b0100:2'd2),
    S3 = (USE_ONEHOT?4'b1000:2'd3)
  } state_t;

  state_t cs, ns;

  // 2) 상태 레지스터
  always @(posedge iCLK or negedge iRESETn) begin
    if(!iRESETn) cs <= S0;
    else         cs <= ns;
  end

  // 3) 다음 상태 조합 논리
  always @* begin
    ns = cs;
    case (cs)
      S0: ns = x ? S1 : S0;
      S1: ns = x ? S2 : S0;
      S2: ns = x ? S3 : S1;
      S3: ns = x ? S3 : S2;
      default: ns = S0;
    endcase
  end

  // 4) 출력 조합 논리(Moore 예시)
  always @* begin
    case (cs)
      S3:     y = 1'b1;
      default:y = 1'b0;
    endcase
  end
endmodule
```

---

### ▶ 설계 체크리스트
- **리셋**: 비동기 리셋 시 민감도 목록에 `negedge iRESETn` 포함.  
- **기본값**: 조합 always 블록 시작 시 `ns=cs;` / 출력 기본값 설정 → **래치 방지**.  
- **Mealy 출력 글리치**: 가능하면 한 클록 지연(레지스터 출력)으로 안정화.  
- **CDC**: 다른 클록 도메인의 입력은 **2-FF 동기화** 후 FSM에 인가.  
- **타이밍 여유**: One-hot 인코딩 고려, 불필요한 긴 조합경로 피하기.  

---

## 7.1 Moore FSM 예제 – 시퀀스 디텍터(1011, 중첩 허용)
```verilog
module seqdet_moore_1011 (
  input  wire iCLK, input wire iRESETn,
  input  wire x,
  output reg  y
);
  typedef enum reg [2:0] {S0, S1, S10, S101, S1011} state_t;
  state_t cs, ns;

  // 상태 레지스터
  always @(posedge iCLK or negedge iRESETn) begin
    if(!iRESETn) cs <= S0;
    else         cs <= ns;
  end

  // 다음 상태 조합 논리
  always @* begin
    ns = cs;
    case (cs)
      S0   : ns = x ? S1   : S0;
      S1   : ns = x ? S1   : S10;   // '1' 유지 or '10'
      S10  : ns = x ? S101 : S0;    // '101' or 리셋
      S101 : ns = x ? S1011: S10;   // '1011' or '10'
      S1011: ns = x ? S1   : S10;   // overlapping 처리
      default: ns = S0;
    endcase
  end

  // 출력(Moore): 상태만의 함수
  always @* begin
    y = (cs == S1011);
  end
endmodule
```

**Testbench**
```verilog
`timescale 1ns/1ps
module tb_seqdet_moore_1011;
  reg clk, rstn, x; wire y;
  seqdet_moore_1011 DUT(.iCLK(clk), .iRESETn(rstn), .x(x), .y(y));
  initial begin clk=0; forever #5 clk=~clk; end
  task APPLY(input [31:0] bits, input integer n);
    integer i;
    begin
      for(i=n-1;i>=0;i=i-1) begin x = bits[i]; @(posedge clk); end
    end
  endtask
  initial begin
    rstn=0; x=0; repeat(2) @(posedge clk); rstn=1;
    // ...1011... 패턴 두 번 포함
    APPLY(32'b1_0_1_1_1_0_1_1, 8);
    repeat(10) @(posedge clk);
    $stop;
  end
endmodule
```

---

## 7.2 Mealy FSM 예제 – 시퀀스 디텍터(1011, 비중첩)
```verilog
module seqdet_mealy_1011_nolap (
  input  wire iCLK, input wire iRESETn,
  input  wire x,
  output reg  y
);
  typedef enum reg [1:0] {S0, S1, S10, S101} state_t;
  state_t cs, ns;

  always @(posedge iCLK or negedge iRESETn) begin
    if(!iRESETn) cs <= S0;
    else         cs <= ns;
  end

  // Mealy: 출력이 입력과 상태의 함수 → 조합에서 산출 (글리치 주의)
  always @* begin
    // 기본값
    ns = cs;
    y  = 1'b0;

    case (cs)
      S0  : begin
              ns = x ? S1 : S0;
            end
      S1  : begin
              ns = x ? S1 : S10;
            end
      S10 : begin
              ns = x ? S101 : S0;
            end
      S101: begin
              if (x) begin
                y  = 1'b1;   // 패턴 1011 완성 시 같은 클록에 1
                ns = S0;     // 비중첩: 초기화
              end else begin
                ns = S10;
              end
            end
      default: ns = S0;
    endcase
  end
endmodule
```

> **글리치 방지 팁**: `y`를 한 클록 레지스터에 저장해 출력하면 파형 안정.

---

## 7.3 타이머 기반 신호등 컨트롤러 (Moore + Enable 타이머)
```verilog
module traffic_light (
  input  wire iCLK, input wire iRESETn,
  input  wire en_1hz,                 // 1Hz enable pulse
  output reg  [2:0] NS,               // {R,Y,G}
  output reg  [2:0] EW
);
  typedef enum reg [1:0] {NS_G, NS_Y, EW_G, EW_Y} state_t;
  state_t cs, ns;
  reg [2:0] tcnt; // 초 카운터(최대 3)

  // 상태 레지스터 & 초 카운터
  always @(posedge iCLK or negedge iRESETn) begin
    if(!iRESETn) begin cs <= NS_G; tcnt <= 0; end
    else begin
      cs <= ns;
      if(en_1hz) begin
        case (cs)
          NS_G, EW_G: tcnt <= (tcnt==3-1) ? 0 : tcnt + 1;  // 3초
          NS_Y, EW_Y: tcnt <= (tcnt==1-1) ? 0 : tcnt + 1;  // 1초
          default:    tcnt <= 0;
        endcase
      end
    end
  end

  // 다음 상태 조합 논리
  always @* begin
    ns = cs;
    case (cs)
      NS_G : ns = (tcnt==3-1 && en_1hz) ? NS_Y : NS_G;
      NS_Y : ns = (tcnt==1-1 && en_1hz) ? EW_G : NS_Y;
      EW_G : ns = (tcnt==3-1 && en_1hz) ? EW_Y : EW_G;
      EW_Y : ns = (tcnt==1-1 && en_1hz) ? NS_G : EW_Y;
      default: ns = NS_G;
    endcase
  end

  // 출력(Moore) – 상태만의 함수
  always @* begin
    case (cs)
      NS_G: begin NS=3'b001; EW=3'b100; end  // NS:G, EW:R
      NS_Y: begin NS=3'b010; EW=3'b100; end  // NS:Y, EW:R
      EW_G: begin NS=3'b100; EW=3'b001; end  // NS:R, EW:G
      EW_Y: begin NS=3'b100; EW=3'b010; end  // NS:R, EW:Y
      default: begin NS=3'b100; EW=3'b100; end
    endcase
  end
endmodule
```

**1Hz Enable 생성기(예: 50 MHz → 1 Hz)**
```verilog
module en1hz #(parameter CLK=50_000_000) (
  input iCLK, input iRESETn, output reg oEN
);
  localparam DIV = CLK-1;
  reg [$clog2(CLK)-1:0] cnt;
  always @(posedge iCLK or negedge iRESETn) begin
    if(!iRESETn) begin cnt<=0; oEN<=1'b0; end
    else if(cnt==DIV) begin cnt<=0; oEN<=1'b1; end
    else begin cnt<=cnt+1'b1; oEN<=1'b0; end
  end
endmodule
```

**Testbench(간단)**
```verilog
`timescale 1ns/1ps
module tb_traffic_light;
  reg clk, rstn; wire en1; wire [2:0] NS, EW;
  en1hz #(.CLK(1_000_000)) EN(.iCLK(clk), .iRESETn(rstn), .oEN(en1)); // TB 가속용 1MHz→1Hz
  traffic_light DUT(.iCLK(clk), .iRESETn(rstn), .en_1hz(en1), .NS(NS), .EW(EW));
  initial begin clk=0; forever #0.5 clk=~clk; end // 1MHz
  initial begin
    rstn=0; repeat(5) @(posedge clk); rstn=1;
    repeat(20) @(posedge clk); // 수 초 관찰
    $stop;
  end
endmodule
```

---

### ▶ Mealy vs Moore 선택 가이드
- **속도 우선 / 상태 수 최소**: Mealy  
- **출력 안정성 / 타이밍 예측**: Moore  
- **실무 팁**: Mealy라도 마지막에 **레지스터 1단**을 통과시켜 **글리치 억제** → Moore와 유사한 안정성 확보

---

### ✅ 요약 체크리스트
- `ns=cs;` / `y=기본값;`로 시작하는 조합 블록 → 래치 방지  
- 비동기 리셋 시 **민감도 목록**과 **리셋 후 초기 상태** 명확화  
- Mealy 출력은 가능하면 **레지스터링**  
- 상태 인코딩은 타이밍/자원에 맞게 **one-hot/compact** 선택  
- 외부 비동기 입력은 **2-FF 동기화** 후 FSM에 투입
