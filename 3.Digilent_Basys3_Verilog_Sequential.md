# 🧩 Digilent Basys3 Verilog 순차회로 모델링
학습목표
❖ 모델링의 기본 단위인 모듈에 대해 이해한다.
❖ 대표적인 순차회로를 모델링할 수 있다.
❖ 유한상태머신에 대한 기본적인 개념을 이해한다.
❖ Mealy FSM과 Moore FSM의 차이를 이해한다.
❖ Mealy FSM과 Moore FSM을 모델링 할 수 있다.


1 순차회로
2 래치와 플립플롭
3 시프트 레지스터
4 카운터
5 주파수 분주기
6 7-세그먼트 디코더
7 유한상태머신

1 순차회로
▶ 순차회로
– 시간의 흐름에 따라 상태가 변함
– 상태는 과거 상태와 현재 입력의 조합으로 결정 – 기억소자O, 상태 레지스터, 카운터, 타이머
▶ 동기식 순차회로
– 클록의 지정된 시점이 주기적으로 반복될 때마다 회로가 동작
– 입출력, 저장, 데이터 처리
– 명확한 시간 간격에 따라 출력이 변함
▶ 비동기식 순차회로
– 클록의 특정 시점과 상관없이 임의 시점에서 입력신호를 반영하여 회로가 동작
– 시간 간격과 무관
– 입력이 변화할 때 출력이 변함
▶ 클록(Clock)
– 논리상태 High(1)와 LOW(0)가 일정한 시간 간격으로 반복 – 주기적으로 반복되는 구형파, T, 초(sec)
– 시간 제어(디지털 회로 입출력, 데이터 처리, 이벤트)

▶ 클록(Clock)
– 레벨(level): 클록의 안정적인 논리상태, High(1), Low(0) – 엣지(edge): 레벨이 변화하는 시점, Low->High, High->Low – 트리거(trigger): 변화를 유발하는 계기, 엣지와 함께 사용
▶ 펄스 신호(Pulse signal)
– 순간적으로 급격히 변화하여 짧은 시간 동안 지속되는 신호
– 주기적인 펄스 신호->클록(50%)
– 듀티 사이클(duty cycle): 한 주기에 High 레벨이 차지하는 시간적 비율

2 래치와 플립플롭
▶ 래치(Latch)
– 데이터나 상태를 저장하는 기본 장치
– 입력 신호에 따라 출력 상태를 유지
– 레벨 감지 방식, 비동기식
–  SR 래치, D 래치
▶ 플립플롭(Flip-Flop)
– 정교한 저장 장치
– 클록 신호의 특정 순간 입력 값을 반영 – 엣지 감지 방식, 동기식, 예측가능, 안정성 – D 플립플롭, JK 플립플롭
▶ 래치와 플립플롭 비교
▶  기본적인 기억소자 (SR 래치)
▶  입력을 제어할 수 있는 (SR 래치)
▶  입력을 제어할 수 있는 (D 래치)
module dlatch(G, d, q); input  G, d;
output q;
reg    q;
always @(G or d) begin if(G)
q <= d;
else
q <= q;
end endmodule

▶  입력을 제어할 수 있는 (D 래치) - 테스트벤치
module tb_dlatch ;
reg clk, d;
dlatch U0(clk, d, q);
initial begin
clk = 1'b0;
forever #10 clk = ~clk;
end
initial begin  
d = 1'b0;
forever begin
#15 d = 1'b1;  #20 d = 1'b0; #10 d = 1'b1;  #10 d = 1'b0; #10 d = 1'b1;  #15 d = 1'b0;
end
end
endmodule

▶  D 플립플롭
–  RS-래치의 G에 클럭(clk) 사용
–  입력 R과 S를 묶어 D라는 기호 사용
–  입력 R 또는 S 중 하나를 인버터로 연결하여 입력으로 사용

module d_ff (d, clk, q); input       d, clk; output     q;
reg          q; always @(posedge clk)
q <= d; endmodule

▶  D 플립플롭의 Edge Detector

▶  q와 q_ 출력을 갖는 Positive edge-triggered D 플립플롭

module d_ff_bad1(clk, d, q, q_bar); input  d, clk;
output q, q_bar;
reg    q, q_bar;
always @(posedge clk) begin
q     <= d;  // q = d;
q_bar <= ~d; // q_ = ~d;
end
endmodule

module d_ff_good(clk, d, q, q_bar); input  d, clk;
output q, q_bar;
reg    q;
// using assign statement for q_bar
assign q_bar = ~q;
always @(posedge clk) q <= d;
endmodule

하나의 always문에 q와 q_ 출력을 모두 갖도록 설계할 경우 2개의 FF이 사용되므로 비효율적 설계
→ q_는 always 문 외부에 assign문을 사용하여 생성
디지털 시스템 설계 및 활용을 위한 Verilog HDL래치와 플립플롭

▶  q와 q_ 출력을 갖는 Positive edge-triggered D 플립플롭의 합성결과 비교

▪ 하나의 always문에
q와 q_ 출력을
모두 설계한 경우
Flip flop
Flip flop
▪ 하나의 always문에
q출력만 기술하고
외부 assign문에
q_ 출력을 기술하여
설계한 경우

▶ 다음 상승엣지 트리거 D-FF을 모델링 해보자.
– 게이트 프리미티브, if 문 두 가지 방법으로 모델링 하라.

▶ 다음 상승엣지 트리거 D-FF을 모델링해보자.
– 게이트 프리미티브, if 문 두 가지 방법으로 모델링 하라.
▶ 게이트 프리미티브를 사용한 D-FF 모델링
module d_ff (
iCLK,          // Active-High 클록(CLK) iCLEARn,       // Active-Low 시스템 클리어(CLRN) iPRESETn,      // Active-Low 프리셋(PRE)
iD,            // D-FF의 입력(D) oQ,            // D-FF의 출력(Q) oQn);          // D-FF의 반전 출력(Q)
input     iCLK, iCLEARn, iPRESETn;
input     iD;
output    oQ, oQn;
wire      w0, w1, w2, w3;       // 1비트 net형으로 생략 가능
// 게이트 프리미티브를 이용한 D-FF의 게이트 수준 모델링 nand  U0 (w0, iPRESETn, w3, w1);  
nand  U1 (w1, w0, iCLK, iCLEARn); nand  U2 (w2, w1, iCLK, w3); nand  U3 (w3, w2, iD, iCLEARn); nand  U4 (oQ, w1, oQn, iPRESETn); nand  U5 (oQn, oQ, w2, iCLEARn);
endmodule

▶ if 문과 논블록킹 할당문을 사용한 D-FF 모델링
module d_ff (
iCLK,          // Active-High 클록(CLK) iCLEARn,       // Active-Low 시스템 클리어(CLRN) iPRESETn,      // Active-Low 프리셋(PRE)
iD,            // D-FF의 입력(D) oQ,            // D-FF의 출력(Q) oQn);          // D-FF의 반전 출력(Q)
input     iCLK, iCLEARn, iPRESETn;
input     iD;
output    oQ, oQn;
reg       oQ;         // always 문 내부의 왼쪽 할당 신호를 reg형으로 선언
assign    oQn = ~oQ;  // oQn는 always 문밖에서 assign문으로 할당됨
always @(posedge iCLK or negedge iCLEARn or negedge iPRESETn) begin if (!iCLEARn)       // 시스템 클리어 동작
oQ  <= 0;        // 순차회로이므로 논블록킹 할당문 사용 else if (!iPRESETn) // 프리셋 동작
oQ  <= 1;        // 순차회로이므로 논블록킹 할당문 사용 else                // 저장 동작
oQ  <= iD;       // 순차회로이므로 논블록킹 할당문 사용
end
endmodule

▶ if 문과 논블록킹 할당문을 사용한 D-FF 모델링
module d_ff (
iCLK,          // Active-High 클록(CLK) iCLEARn,       // Active-Low 시스템 클리어(CLRN) iPRESETn,      // Active-Low 프리셋(PRE)
iD,            // D-FF의 입력(D) oQ,            // D-FF의 출력(Q) oQn);          // D-FF의 반전 출력(Q)
input     iCLK, iCLEARn, iPRESETn;
input     iD;
output    oQ, oQn;
reg     oQ, oQn;  // oQn을 reg형으로 추가 선언
always @(posedge iCLK or negedge iCLEARn or negedge iPRESETn) begin if (!iCLEARn) begin       
oQ  <= 0;
oQn <= 0;
end
else if (!iPRESETn) begin
oQ  <= 1;
oQn <= 0;
end        
else begin               
oQ  <= iD;
oQn < = ~oQ;
end      end
endmodule

▶ D-FF 테스트벤치
`timescale  1ns/10ps
module  tb_d_ff;
reg       iCLK, iCLEARn, iPRESETn, iD; wire      oQ, oQn;
d_ff U0 (
.iCLK       (iCLK),
.iCLEARn    (iCLEARn), 
.iPRESETn   (iPRESETn),
.iD         (iD),
.oQ
.oQn
(oQ),
(oQn));
initial begin
iCLEARn = 1; iPRESETn = 1; iD = 0; #50;
iCLEARn = 0; iPRESETn = 1; iD = 0; #30;    // system clear iCLEARn = 1; iPRESETn = 0; iD = 0; #30;    // preset iCLEARn = 1; iPRESETn = 1; iD = 0; #100;   // set and hold iCLEARn = 1; iPRESETn = 1; iD = 1; #100;   // set and hold iCLEARn = 1; iPRESETn = 1; iD = 0; #100;   // set and hold iCLEARn = 1; iPRESETn = 1; iD = 1; #100;   // set and hold iCLEARn = 1; iPRESETn = 1; iD = 0; #100;   // set and hold
$stop;
end  

initial   iCLK = 0;
always    #50 iCLK = ~iCLK;
endmodule


▶ 다음 상승엣지 트리거 JK-FF을 모델링 해보자.
– 게이트 프리미티브, if 문 두 가지 방법으로 모델링 하라.

▶ 게이트 프리미티브를 사용한 JK-FF 모델링 (D-FF)
module d_ff (
iCLK,          // Active-High 클록(CLK) iCLEARn,       // Active-Low 시스템 클리어(CLRN) iPRESETn,      // Active-Low 프리셋(PRE)
iD,            // D-FF의 입력(D) oQ,            // D-FF의 출력(Q) oQn);          // D-FF의 반전 출력(Q)
input     iCLK, iCLEARn, iPRESETn;
input     iD;
output    oQ, oQn;
reg       oQ;         // always 문 내부의 왼쪽 할당 신호를 reg형으로 선언
assign    oQn = ~oQ;  // oQn는 always 문밖에서 assign문으로 할당됨
always @(posedge iCLK or negedge iCLEARn or negedge iPRESETn) begin if (!iCLEARn)       // 시스템 클리어 동작
oQ  <= 0;        // 순차회로이므로 논블록킹 할당문 사용 else if (!iPRESETn) // 프리셋 동작
oQ  <= 1;        // 순차회로이므로 논블록킹 할당문 사용 else                // 저장 동작
oQ  <= iD;       // 순차회로이므로 논블록킹 할당문 사용
end
endmodule

▶ 게이트 프리미티브를 사용한 JK-FF 모델링
module jk_ff (
iCLK,         // Active-High 클록(CLK) iCLEARn,      // Active-Low 시스템 클리어(CLRN) iPRESETn,     // Active-Low 프리셋(PRE)
iJ,           // JK-FF의 입력(J)
iK,           // JK-FF의 입력(K) oQ,           // JK-FF의 출력(Q) oQn);         // JK-FF의 반전 출력(Q)
input     iCLK, iCLEARn, iPRESETn; input     iJ, iK;
output 
wire     
oQ, oQn;
 w0, w1, w2, w3;      // 1비트 net형으로 생략 가능

not   U0  (w0, iK); nand  U1  (w1, oQn, iJ); nand  U2  (w2, w0, oQ); nand  U3  (w3, w1, w2);
d_ff  UDFF (        
.iCLK       (iCLK),
.iCLEARn    (iCLEARn),
.iPRESETn   (iPRESETn),
.iD         (w3),
.oQ         (oQ),
.oQn        (oQn)); endmodule


▶ if 문과 논블록킹 할당문을 사용한 JK-FF 모델링
module jk_ff (
iCLK,         // Active-High 클록(CLK) iCLEARn,      // Active-Low 시스템 클리어(CLRN) iPRESETn,     // Active-Low 프리셋(PRE)
iJ,           // JK-FF의 입력(J)
iK,           // JK-FF의 입력(K) oQ,           // JK-FF의 출력(Q) oQn);         // JK-FF의 반전 출력(Q)
input     iCLK, iCLEARn, iPRESETn; input     iJ, iK;
output 
reg      
oQ, oQn;
oQ;
assign    oQn = ~oQ;
always @(posedge iCLK or negedge iCLEARn or negedge iPRESETn) begin if(!iCLEARn)                  // 시스템 클리어 동작
oQ <= 0;
else if (!iPRESETn)           // 프리셋 동작
oQ <= 1;
else 
case({iJ, iK})
2'b00   : oQ <= oQ;     // hold      : iJ = 0, iK = 0 2'b01   : oQ <= 1'b0;   // reset     : iJ = 0, iK = 1 2'b10   : oQ <= 1'b1;   // set       : iJ = 1, iK = 0 2'b11   : oQ <= oQn;    // inversion : iJ = 1, iK = 1 default : oQ <= 1'bz;   // latch 방지
endcase
end
endmodule

 ▶ JK-FF 테스트벤치
`timescale  1ns/10ps
module  tb_jk_ff;
reg       iCLK, iCLEARn, iPRESETn, iJ, iK; wire      oQ, oQn;
jk_ff UDFF (
.iCLK       (iCLK),
.iCLEARn    (iCLEARn), 
.iPRESETn   (iPRESETn),
.iJ         (iJ),
.iK
.oQ
(iK),
(oQ),
.oQn
(oQn));
initial begin
iCLEARn = 1; iPRESETn = 1; iJ = 0; iK = 0; #50;
iCLEARn = 0; iPRESETn = 1; iJ = 0; iK = 0; #30;    // system reset iCLEARn = 1; iPRESETn = 0; iJ = 0; iK = 0; #30;    // preset iCLEARn = 1; iPRESETn = 1; iJ = 0; iK = 1; #100;   // reset iCLEARn = 1; iPRESETn = 1; iJ = 0; iK = 0; #100;   // hold iCLEARn = 1; iPRESETn = 1; iJ = 1; iK = 0; #100;   // set iCLEARn = 1; iPRESETn = 1; iJ = 0; iK = 0; #100;   // hold iCLEARn = 1; iPRESETn = 1; iJ = 0; iK = 1; #100;   // reset iCLEARn = 1; iPRESETn = 1; iJ = 0; iK = 0; #100;   // hold iCLEARn = 1; iPRESETn = 1; iJ = 1; iK = 1; #200;   // inversion
$stop;
end
initial   iCLK = 0;
always    #50 iCLK = ~iCLK; endmodule


3 시프트 레지스터

▶ 시프트 레지스터
– 여러 개의 플립플롭이 직렬로 연결된 구조
– 직병렬 입출력을 갖는 디지털 회로
– SISO, SIPO, PISO, PIPO
– 버퍼 회로, 데이터 저장 회로, 시간지연 회로, 되먹임 시프트 레지스터 회로

▶ 구조적 방법을 사용한 SIPO 시프트 레지스터 (D-FF)
module d_ff (
iCLK,          // Active-High 클록(CLK) iCLEARn,       // Active-Low 시스템 클리어(CLRN) iPRESETn,      // Active-Low 프리셋(PRE)
iD,            // D-FF의 입력(D) oQ,            // D-FF의 출력(Q) oQn);          // D-FF의 반전 출력(Q)
input     iCLK, iCLEARn, iPRESETn;
input     iD;
output    oQ, oQn;
reg       oQ;         // always 문 내부의 왼쪽 할당 신호를 reg형으로 선언

assign    oQn = ~oQ;  // oQn는 always 문밖에서 assign문으로 할당됨
always @(posedge iCLK or negedge iCLEARn or negedge iPRESETn) begin if (!iCLEARn)       // 시스템 클리어 동작
oQ  <= 0;        // 순차회로이므로 논블록킹 할당문 사용 else if (!iPRESETn) // 프리셋 동작
oQ  <= 1;        // 순차회로이므로 논블록킹 할당문 사용 else                // 저장 동작
oQ  <= iD;       // 순차회로이므로 논블록킹 할당문 사용
end
endmodule

▶ 구조적 방법을 사용한 SIPO 시프트 레지스터
module sipo (
iCLK,          // 클록, Active-High
iRESETn,       // 리셋, Active-Low 
iS,            // 1비트 직렬 입력
oP);           // 4비트 병렬 출력
input          iCLK, iRESETn;
input          iS;               // 직렬 입력 데이터 output   [3:0] oP;               // 4bit 병렬 출력
d_ff UFF0 (
.iCLK       (iCLK),
.iCLEARn    (iRESETn),
.iPRESETn   (1'b1),
.iD         (iS),      
.oQ         (oP[0]));  
d_ff UFF1 (
.iCLK       (iCLK),
.iCLEARn    (iRESETn),
.iPRESETn   (1'b1),
.iD         (oP[0]),
.oQ         (oP[1]));
d_ff UFF2 (
.iCLK       (iCLK),
.iCLEARn    (iRESETn),
.iPRESETn   (1'b1),
.iD         (oP[1]),      
.oQ         (oP[2]));
d_ff UFF3 (
.iCLK       (iCLK),
.iCLEARn    (iRESETn),
.iPRESETn   (1'b1),
.iD         (oP[2]),      
.oQ         (oP[3])); endmodule


▶ 조건연산자를 사용한 SIPO 시프트 레지스터
module sipo (
iCLK,          // 클록, Active-High
iRESETn,       // 리셋, Active-Low 
iS,            // 1비트 직렬 입력
oP);           // 4비트 병렬 출력
input          iCLK, iRESETn;
input          iS;    // 직렬 입력 데이터
output   [3:0] oP;    // 4bit 병렬 출력
reg      [3:0] p_out;

assign   oP = p_out;
reg      [3:0] p_out;  // always 문 내부의 왼쪽 신호이므로 reg형으로 선언
always @(posedge iCLK or negedge iRESETn) beg p_out  <=  (!iRESETn) ? 4'b0 : {p_out, iS};
end
endmodule

▶ if 문을 사용한 SIPO 시프트 레지스터
module sipo (
iCLK,          // 클록, Active-High iRESETn,       // 리셋, Active-Low iS,            // 1비트 직렬 입력
oP);           // 4비트 병렬 출력
input          iCLK, iRESETn;
input          iS;   // 직렬 입력 데이터
output 
reg      
  [3:0] oP;   // 4bit 병렬 출력
[3:0] p_out;  // always 문 내부의 왼쪽 신호이므로 reg형으로 선언
assign   oP = p_out;
always @(posedge iCLK or negedge iRESETn) begin if (!iRESETn)
p_out <= 4'b0;
else begin 
p_out <= (p_out << 1); p_out[0] <= iS;
end
end
endmodule

▶ SIPO 시프트 레지스터 테스트벤치
`timescale  1ns/10ps
module  tb_sipo;
reg          iCLK, iRESETn; reg          iS;
wire   [3:0] oP; 
sipo U0 (
.iCLK      (iCLK), 
.iRESETn
.iS
(iRESETn), 
(iS), 
.oP
(oP));

initial begin
iRESETn = 1; iS = 1'b0; #100;
iRESETn = 0; iS = 1'b0; #30;   // Avtive-Low reset iRESETn = 1; iS = 1'b0; #100;  // 1bit left shift iRESETn = 1; iS = 1'b0; #100;  // 1bit left shift iRESETn = 1; iS = 1'b1; #100;  // 1bit left shift iRESETn = 1; iS = 1'b0; #100;  // 1bit left shift iRESETn = 1; iS = 1'b0; #100;  // 1bit left shift iRESETn = 1; iS = 1'b1; #100;  // 1bit left shift
$stop;
end    
initial   iCLK = 0;
always   #50 iCLK = ~iCLK; endmodule


▶ 다음 PISO 시프트 레지스터를 모델링 해보자.
– 구조적 방법, 조건연산자, if 문 세 가지 방법으로 모델링 하라.

▶ 구조적 방법을 사용한 PISO 시프트 레지스터 (2x1 mux)
/* 조건연산자와 assign 문을 사용한 2×1 MUX 모듈 */ module mux2to1 (iA, iB, iSEL, oY);
input          iA, iB;
input          iSEL;
output         oY;
// assign 문과 조건 연산자 사용 assign   oY = (iSEL == 0) ? iA : iB; 
endmodule
/* always 문 내부에서 if 문을 이용한 D-FF */
module d_ff (
iCLK,          // Active-High 클록(CLK) iCLEARn,       // Active-Low 시스템 클리어(CLRN) iPRESETn,      // Active-Low 프리셋(PRE)
iD,            // D-FF의 입력(D) oQ,            // D-FF의 출력(Q) oQn);          // D-FF의 반전 출력(Q)
input     iCLK, iCLEARn, iPRESETn;
input     iD;
output    oQ, oQn;
reg       oQ;         // always 문 내부의 왼쪽 할당 신호를 reg형으로 선언

assign    oQn = ~oQ;  // oQn는 always 문밖에서 assign문으로 할당됨
always @(posedge iCLK or negedge iCLEARn or negedge iPRESETn) begin
if (!iCLEARn)       // 시스템 클리어 동작
oQ  <= 0;        // 순차회로이므로 논블록킹 할당문 사용 else if (!iPRESETn) // 프리셋 동작
oQ  <= 1;        // 순차회로이므로 논블록킹 할당문 사용 else                // 저장 동작
oQ  <= iD;       // 순차회로이므로 논블록킹 할당문 사용
end
endmodule


▶ 구조적 방법을 사용한 PISO 시프트 레지스터
module piso (
iCLK,     // 클록, Active-High
iRESETn,  // 리셋, Active-Low 
iLOADn,   // 데이터 load를 위한 제어신호, Active-Low iP,       // 4비트 병렬 입력
oS);      // 1비트 직렬 출력
input          iCLK, iRESETn, iLOADn; input    [3:0] iP;   // 병렬 입력 데이터 output         oS;   // 직렬 출력
wire   w0, w1, w2, w3, w4, w5, w6, s7, w8, w9, w10, w11, w12; wire   y0, y1, y2, y3;
wire   q0, q1, q2;
not   U0  (w0, iLOADn); nand  U1  (w1, y0, w0); nand  U2  (w2, w0, w1); and   U3  (w3, w2, iRESETn); nand  U4  (w4, y1, w0); nand  U5  (w5, w0, w4); and   U6  (w6, w5, iRESETn); nand  U7  (w7, y2, w0); nand  U8  (w8, w0, w7); and   U9  (w9, w8, iRESETn); nand  U10 (w10, y3, w0); nand  U11 (w11, w0, w10); and   U12 (w12, w11, iRESETn);

// MUX와 D-FF의 인스턴스화
mux2to1  UMUX0 (
.iA        (iP[0]),
.iB        (1'b0),
.iSEL      (iLOADn),   // MUX 제어신호(iLOADn) 
.oY        (y0)        // MUX3의 출력(oY)
);
d_ff  UFF0 (
.iCLK      (iCLK),  // Active-High 클록(CLK)
.iCLEARn   (w3),    // Active-Low 시스템 클리어(CLRN)
.iPRESETn  (w1),    // Active-Low 프리셋(PRE)
.iD        (1'b0),  // D-FF의 입력(D)
.oQ        (q0)     // D-FF의 출력(Q)
);
mux2to1  UMUX1 (
.iA        (iP[1]),
.iB        (1'b0),
.iSEL      (iLOADn),   // MUX 제어신호(iLOADn) 
.oY        (y1)        // MUX3의 출력(oY)
);
d_ff  UFF1 (
.iCLK      (iCLK),  // Active-High 클록(CLK)
.iCLEARn   (w6),    // Active-Low 시스템 클리어(CLRN)
.iPRESETn  (w4),    // Active-Low 프리셋(PRE)
.iD        (q0),    // D-FF의 입력(D)
.oQ        (q1)     // D-FF의 출력(Q)
);
mux2to1  UMUX2 (
.iA        (iP[2]),
.iB        (1'b0),
.iSEL      (iLOADn),   // MUX 제어신호(iLOADn) 
.oY        (y2)        // MUX3의 출력(oY)
);
d_ff  UFF2 (
.iCLK      (iCLK),  // Active-High 클록(CLK)
.iCLEARn   (w9),    // Active-Low 시스템 클리어(CLRN)
.iPRESETn  (w7),    // Active-Low 프리셋(PRE)
.iD        (q1),    // D-FF의 입력(D)
.oQ        (q2)     // D-FF의 출력(Q)
); 

mux2to1  UMUX3 (
.iA        (iP[3]),
.iB        (1'b0),
.iSEL      (iLOADn),   // MUX 제어신호(iLOADn) 
.oY        (y3)        // MUX3의 출력(oY)
);
d_ff  UFF3 (
.iCLK      (iCLK),  // Active-High 클록(CLK)
.iCLEARn   (w12),   // Active-Low 시스템 클리어(CLRN)
.iPRESETn  (w10),   // Active-Low 프리셋(PRE)
.iD        (q2),    // D-FF의 입력(D)
.oQ        (oS)     // D-FF의 출력(Q)
);
endmodule

▶ 조건연산자를 사용한 PISO 시프트 레지스터
module piso (
iCLK,      // 클록
iRESETn,   // Active-Low 리셋
iLOADn,    // 데이터 load를 위한 제어신호, Active-Low
iP,        // 4비트 병렬 입력
oS);       // 1비트 직렬 출력
input          iCLK, iRESETn, iLOADn;
input    [3:0] iP;   // 4bit 병렬 입력 데이터
output         oS;   // 1bit 직렬 출력
reg      [3:0] q_ff;   // always 문 내부의 왼쪽 신호이므로 reg형으로 선언

always @(posedge iCLK or negedge iRESETn or negedge iLOADn) begin
q_ff  <=  (!iRESETn) ? 4'b0 : (!iLOADn) ? iP : {q_ff, 1'b0};
end
assign oS = q_ff[3];
endmodule

▶ if 문을 사용한 PISO 시프트 레지스터
module piso (
iCLK,      // 클록
iRESETn,   // Active-Low 리셋
iLOADn,    // 데이터 load를 위한 제어신호, Active-Low
iP,        // 4비트 병렬 입력
oS);       // 1비트 직렬 출력
input          iCLK, iRESETn, iLOADn;
input    [3:0] iP;   // 4bit 병렬 입력 데이터
output         oS;   // 1bit 직렬 출력
reg      [3:0] q_ff; // always 문 내부의 왼쪽 신호이므로 reg형으로 선언
always @(posedge iCLK, negedge iRESETn, negedge iLOADn) begin if (!iRESETn)
q_ff <= 4'b0;
else if (!iLOADn) 
q_ff <= iP;
else begin 
q_ff <= (q_ff << 1);
q_ff[0] <= 1'b0;
end
end
assign oS = q_ff[3];
endmodule


4 카운터
▶ 카운터
– 제어회로 모델링에 자주 사용하는 순차회로 – 클록 입력마다 수를 세는 동작
– 순차 제어, 타이밍, 주파수 분할 및 측정
구분 요소
종류
동기 방식
동기식 카운터, 비동기식 카운터
카운트 범위
N비트 2진 카운터, 10진 카운터(4비트)
계수값 증감
증가형 카운터, 감소형 카운터
< 카운터의 구분 요소 >

▶ 비동기식 4비트 2진 증가형 카운터
– 직렬로 연결된 N개의 플립플롭으로 구성 – 출력이 순차적으로 발생(ripple counter) – 간단한 회로, 느림
▶ 다음 비동기식 4비트 2진 증가형 카운터를 모델링 해보자.
– 구조적 방법, 행위 수준 두 가지 방법으로 모델링 하라.
▶ 구조적 방법을 사용한 비동기식 4비트 2진 증가형 카운터(JK)
module jk_ff (
iCLK,         // Active-High 클록(CLK) iCLEARn,      // Active-Low 시스템 클리어(CLRN) iPRESETn,     // Active-Low 프리셋(PRE)
iJ,           // JK-FF의 입력(J)
iK,           // JK-FF의 입력(K) oQ,           // JK-FF의 출력(Q) oQn);         // JK-FF의 반전 출력(Q)
input     iCLK, iCLEARn, iPRESETn; input     iJ, iK;
output 
reg      
oQ, oQn;
oQ;
assign    oQn = ~oQ;
always @(posedge iCLK or negedge iCLEARn or negedge iPRESETn) begin if(!iCLEARn)                  // 시스템 클리어 동작
oQ <= 0;
else if (!iPRESETn)           // 프리셋 동작
oQ <= 1;
else 
case({iJ, iK})
2'b00   : oQ <= oQ;     // hold      : iJ = 0, iK = 0 2'b01   : oQ <= 1'b0;   // reset     : iJ = 0, iK = 1 2'b10   : oQ <= 1'b1;   // set       : iJ = 1, iK = 0 2'b11   : oQ <= oQn;    // inversion : iJ = 1, iK = 1 default : oQ <= 1'bz;   // latch 방지
endcase
end
endmodule

▶ 비동기식 4비트 2진 증가형 카운터 – 구조적 방법

module  ripple_upcnt (
iCLK,      // 기준 클록
iRESETn,   // 리셋(system clear), Active-Low
oQ);       // 4비트 2진 증가형 카운터의 출력
input           iCLK, iRESETn;
output    [3:0] oQ;
wire      [3:0] oQ;
jk_ff UFF0 (
.iCLK      (~iCLK),  // 클록의 하강엣지 동작을 위해 반전된 클록을 사용
.iCLEARn   (iRESETn),
.iPRESETn  (1'b1),   // 미사용 기능, 정상 동작을 위해 1'b1로 처리
.iJ        (1'b1),   // iJ = 1'b1이 입력됨
.iK
.oQ
(1'b1),   // iK = 1'b1이 입력됨
(oQ[0]));
jk_ff UFF1 (
.iCLK      (~oQ[0]), // 하위비트 JK-FF의 출력을 반전하여 클록으로 사용
.iCLEARn   (iRESETn),
.iPRESETn  (1'b1),   // 미사용 기능, 정상 동작을 위해 1'b1로 처리
.iJ        (1'b1),   // iJ = 1'b1이 입력됨
.iK        (1'b1),   // iK = 1'b1이 입력됨
.oQ        (oQ[1]));
jk_ff UFF2 (
.iCLK      (~oQ[1]), 
.iCLEARn   (iRESETn),
.iPRESETn  (1'b1),   
.iJ        (1'b1),   
.iK        (1'b1),   
.oQ        (oQ[2]));
jk_ff UFF3 (
.iCLK      (~oQ[2]), 
.iCLEARn   (iRESETn),
.iPRESETn  (1'b1),   
.iJ        (1'b1),   
.iK        (1'b1),   
.oQ        (oQ[3]));    endmodule

▶ 비동기식 4비트 2진 증가형 카운터 – 행위 수준 1
module  ripple_upcnt (
iCLK,      // 기준 클록
iRESETn,   // 리셋(system clear), Active-Low   oQ);       // 4비트 2진 증가형 카운터의 출력
input          iCLK, iRESETn;
output   [3:0] oQ;
reg      [3:0] qout;
assign   oQ   = qout;  // 출력 포트 신호에 reg형 qout에 저장값 할당
always @(negedge iCLK or negedge iRESETn) begin  // LSB(oQ[0]) 해당 JK-FF if (!iRESETn)
qout[0] <= 1'b0;
else
qout[0] <= ~qout[0];
end
always @(negedge qout[0] or negedge iRESETn) begin // qout[1] 해당 JK-FF if (!iRESETn)
qout[1] <= 1'b0;
else
qout[1] <= ~qout[1];
end
always @(negedge qout[1] or negedge iRESETn) begin // qout[2] 해당 JK-FF if (!iRESETn)
qout[2] <= 1'b0;
else
qout[2] <= ~qout[2];
end
always @(negedge qout[2] or negedge iRESETn) begin // qout[3] 해당 JK-FF if (!iRESETn)
qout[3] <= 1'b0;
else
qout[3] <= ~qout[3];
end
endmodule


▶ 비동기식 4비트 2진 증가형 카운터 테스트벤치
`timescale  1ns/10ps
module  tb_ripple_upcnt;
reg          iCLK, iRESETn;
wire   [3:0] oQ;
ripple_upcnt U0 (   // 증가형 카운터
.iCLK      (iCLK), 
.iRESETn   (iRESETn), 
.oQ        (oQ));
initial   iCLK = 0;
initial begin
iRESETn = 1; #100; iRESETn = 0; #100;   //Act
운터의 출력값 = 0;  
증
iRESETn = 1; #2000;   // $stop;
end
always    #50 iCLK = ~iCLK; endmodule

▶ 동기식 4비트 2진 증가/감소형 카운터의 모듈
– 각 FF의 입력 -> 기준 클록에 동기화 – 회로가 복잡, 동시 동작->빠름

▶ 동기식 4비트 2진 증가/감소형 카운터 – 구조적 방법(JK)
module jk_ff (
iCLK,         // Active-High 클록(CLK) iCLEARn,      // Active-Low 시스템 클리어(CLRN) iPRESETn,     // Active-Low 프리셋(PRE)
iJ,           // JK-FF의 입력(J)
iK,           // JK-FF의 입력(K) oQ,           // JK-FF의 출력(Q) oQn);         // JK-FF의 반전 출력(Q)
input     iCLK, iCLEARn, iPRESETn; input     iJ, iK;
output 
reg      
oQ, oQn;
oQ;

assign    oQn = ~oQ;
always @(posedge iCLK or negedge iCLEARn or negedge iPRESETn) begin if(!iCLEARn)                  // 시스템 클리어 동작
oQ <= 0;
else if (!iPRESETn)           // 프리셋 동작
oQ <= 1;
else 
case({iJ, iK})
2'b00   : oQ <= oQ;     // hold      : iJ = 0, iK = 0 2'b01   : oQ <= 1'b0;   // reset     : iJ = 0, iK = 1 2'b10   : oQ <= 1'b1;   // set       : iJ = 1, iK = 0 2'b11   : oQ <= oQn;    // inversion : iJ = 1, iK = 1 default : oQ <= 1'bz;   // latch 방지
endcase
end
endmodule


▶ 동기식 4비트 2진 증가/감소형 카운터 – 구조적 방법
module sync_cnt (
iCLK,         // 클록
iRESETn,      // Active-Low 리셋(system clear) iSEL,         // 카운터의 증가/감소 동작 제어신호 oQ);          // 카운터의 출력
input          iCLK, iRESETn;
input          iSEL; 
output   [3:0] oQ;
wire           w0, w1, w2, w3, w4, w5, w6, w7, w8, w9; // 생략 가능 wire     [3:0] oQ, oQn;  
jk_ff UFF0 (
.iCLK       (iCLK), 
.iCLEARn    (iRESETn), 
.iPRESETn   (1'b1), 
.iJ         (1'b1),      // iJ = 1'b1이 입력됨
.iK         (1'b1),      // iK = 1'b1이 입력됨 
.oQ         (oQ[0]),
.oQn        (oQn[0]));
not U0 (w0, iSEL);
and U1 (w1, iSEL, oQ[0]);
and U2 (w2, w0, oQn[0]);
or  U3 (w3, w1, w2);
jk_ff UFF1 (
.oQ         (oQ[0]),
.oQn        (oQn[0]));
not U0 (w0, iSEL);
and U1 (w1, iSEL, oQ[0]);
and U2 (w2, w0, oQn[0]);
or  U3 (w3, w1, w2);
.iCLK       (iCLK), 
.iCLEARn    (iRESETn), 
.iPRESETn   (1'b1), 
.iJ (w3),      // iJ
.iK (w3),      // iK
.oQ         (oQ[1]),
.oQn        (oQn[1]));
= 1'b1이 입력됨
= 1'b1이 입력됨
and U4 (w4, w1, oQ[1]); and U5 (w5, w2, oQn[1]); or  U6 (w6, w4, w5);
jk_ff UFF2 (
.iCLK       (iCLK), 
.iCLEARn    (iRESETn), 
.iPRESETn   (1'b1), 
.iJ         (w6),      // iJ = 1'b1이 입력됨
.iK         (w6),      // iK = 1'b1이 입력됨
.oQ         (oQ[2]),
.oQn        (oQn[2]));
and U7 (w7, w4, oQ[2]); and U8 (w8, w5, oQn[2]); or  U9 (w9, w7, w8);

jk_ff UFF3 (
.iCLK       (iCLK), 
.iCLEARn    (iRESETn), 
.iPRESETn   (1'b1), 
.iJ         (w9),      // iJ
.iK         (w9),      // iK
.oQ         (oQ[3]),
.oQn        (oQn[3])); endmodule
▶ 동기식 4비트 2진 증가/감소형 카운터 – 행위 수준
module sync_cnt (
iCLK,      // 클록
iRESETn,   // Active-Low 리셋(system clear) iSEL,      // 카운터의 증가/감소 동작 제어신호 oQ);       // 카운터의 출력
input           iCLK, iRESETn; input           iSEL; 
output 
reg      
   [3:0] oQ;
 [3:0] qout;
 assign    oQ = qout;
always @(posedge iCLK or negedge iRESETn) begin
if (!iRESETn)
qout <= 4'b0;
else 
case(iSEL)
0       : qout <= qout - 1; // sel = 0, 감소형 카운터 동작 1       : qout <= qout + 1; // sel = 1, 증가형 카운터 동작 default : qout <= 4'b0;     // 불필요한 래치 회로 생성 방지
endcase
end
endmodule

▶ 동기식 4비트 2진 증가/감소형 카운터 – 테스트벤치
`timescale  1ns/10ps
module  tb_sync_cnt;
reg          iCLK, iRESETn, iSEL; wire   [3:0] oQ;
sync_cnt U0 (
.iCLK      (iCLK), 
.iRESETn
.iSEL
(iRESETn),
(iSEL),
.oQ
(oQ));

initial   iCLK = 1;
initial begin
iRESETn = 1; iSEL = 1; #60;    
iRESETn = 0; iSEL = 1; #80;    // Active-Low reset, 카운터 리셋 iRESETn = 1; iSEL = 1; #1500;  // up counter 동작
iRESETn = 1; iSEL = 0; #1500;  // down counter 동작 $stop;
end
always    #50 iCLK = ~iCLK;
endmodule


▶ BCD 카운터
– 0~9 -> 4비트 2진수
– 10진 카운터(decade counter) or Modulo-10 카운터 – 내부 회로 구성에 따라 다양한 모델링 가능


▶ Active-High BCD 카운터 – 구조적 방법(JK)
module jk_ff (
iCLK,         // Active-High 클록(CLK) iCLEARn,      // Active-Low 시스템 클리어(CLRN) iPRESETn,     // Active-Low 프리셋(PRE)
iJ,           // JK-FF의 입력(J)
iK,           // JK-FF의 입력(K) oQ,           // JK-FF의 출력(Q) oQn);         // JK-FF의 반전 출력(Q)
input     iCLK, iCLEARn, iPRESETn; input     iJ, iK;
output 
reg      
oQ, oQn;
oQ;
assign    oQn = ~oQ;
always @(posedge iCLK or negedge iCLEARn or negedge iPRESETn) begin if(!iCLEARn)                  // 시스템 클리어 동작
oQ <= 0;
else if (!iPRESETn)           // 프리셋 동작
oQ <= 1;
else 
case({iJ, iK})
2'b00   : oQ <= oQ;     // hold      : iJ = 0, iK = 0 2'b01   : oQ <= 1'b0;   // reset     : iJ = 0, iK = 1 2'b10   : oQ <= 1'b1;   // set       : iJ = 1, iK = 0 2'b11   : oQ <= oQn;    // inversion : iJ = 1, iK = 1 default : oQ <= 1'bz;   // latch 방지
endcase
end
endmodule

▶ Active-High BCD 카운터 – 구조적 방법
module sync_bcd_cnt (
iCLK,      // 기준 클록
iRESETn,   // Active-Low 리셋(system clear) oBCD);     // BCD 카운터의 출력
input           iCLK, iRESETn;
output    [3:0] oBCD;
wire            w0, w1, w2, w3, w4; // 생략 가능 wire      [3:0] oBCD, oBCDn;  

jk_ff UFF0 (
.iCLK       (iCLK), 
.iCLEARn    (iRESETn), 
.iPRESETn   (1'b1), 
.iJ         (1'b1),      // iJ = 1'b1이 입력됨
.iK         (1'b1),      // iK = 1'b1이 입력됨
.oQ         (oBCD[0]),
.oQn        (oBCDn[0]));
jk_ff UFF1 (
.iCLK       (iCLK), 
.iCLEARn    (iRESETn), 
.iPRESETn   (1'b1), 
.iJ         (w0),      // iJ = 1'b1이 입력됨
.iK
.oQ
(w0),      // iK = 1'b1이 입력됨
(oBCD[1]),
.oQn
(oBCDn[1]));
jk_ff UFF2 (
.iCLK       (iCLK), 
.iCLEARn    (iRESETn), 
.iPRESETn   (1'b1), 
.iJ         (w1),      // iJ = 1'b1이 입력됨
.iK (w1),      // iK = 1'b1이 입력됨 
.oQ         (oBCD[2]),
.oQn        (oBCDn[2]));
jk_ff UFF3 (
.iCLK       (iCLK), 
.iCLEARn    (iRESETn), 
.iPRESETn   (1'b1), 
.iJ (w4),      // iJ = 1'b1이 입력됨
.iK (w4),      // iK = 1'b1이 입력됨
.oQ         (oBCD[3]),
.oQn        (oBCDn[3]));

and  U0 (w0, oBCD[0], oBCD[3]);
and  U1 (w1, oBCD[1], oBCD[0]);
and  U2 (w2, w1, oBCD[2]);
and  U3 (w3, oBCD[0],oBCD[3]);
or   U4 (w4, w2, w3);
endmodule

▶ Active-High BCD 카운터 – 행위 수준
module sync_bcd_cnt (
iCLK,      // 기준 클록
iRESETn,   // Active-Low 리셋(system clear) oBCD);     // BCD 카운터의 출력
input          iCLK, iRESETn;
output 
reg      
  [3:0] oBCD;
[3:0] bcd; 
assign   oBCD = bcd;
always @ (posedge iCLK or negedge iRESETn) begin if (!iRESETn)
bcd <= 4'b0; else if (bcd < 4'd9)
bcd <= bcd + 1;
else
bcd <= 0;
end
endmodule

▶ Active-High BCD 카운터 – 테스트벤치
`timescale  1ns/10ps
module  tb_sync_bcd_cnt; reg          iCLK, iRESETn; wire   [3:0] oBCD;
sync_bcd_cnt U0 (
.iCLK      (iCLK), 
.iRESETn   (iRESETn),     
.oBCD      (oBCD));
initial   iCLK = 1;
initial begin
iRESETn = 1; #100;
iRESETn = 0; #80;    // Active-Low res
iRESETn = 1; #2000;  // up counter 동 $stop;
end
always    #50 iCLK = ~iCLK;
endmodule


5 주파수 분주기
▶ 주파수 분주기
– OSC에서 발생하는 높은 주파수의 클록 펄스로부터 원하는 낮은 주파수의 클록 신호를 생성하는 회로
▶ 기준 클록으로부터 원하는 주파수의 클록을 출력 – 행위 수준
odule freq_div (
iCLK,      // 외부 기준 클록
iRESETn,   // Active-Low 리셋
oMYCLK);   // 원하는 주파수의 클록
localparam   VAL_CNT = 19'd500000;  // 반주기 카운트 값을 파라미터 선언 localparam   WIDTH = 19;
input               iCLK, iRESETn;
output  
reg
oMYCLK;
[WIDTH-1:0] cnt_clk;
reg       
myclk;
assign   oMYCLK = myclk;
always @(posedge iCLK or negedge iRESETn)  begin if (!iRESETn) begin 
cnt_clk   <=  0;
myclk     <=  1;
end
else if (cnt_clk == VAL_CNT - 1)  begin cnt_clk   <=  0;
myclk     <=  ~myclk; 
end
else
cnt_clk   <=  cnt_clk + 1;
end
endmodule

▶ 기준 클록으로부터 원하는 주파수의 클록을 출력 – 테스트벤치
`timescale  1ns/10ps
module  tb_freq_div;
localparam   TCLK = 1000;          // TCLK = 1000 * 1ns = 1us
reg       iCLK, iRESETn;
wire      oMYCLK;
freq_div U0 (
.iCLK      (iCLK), 
.iRESETn
.oMYCLK
(iRESETn),
(oMYCLK));
initial   begin
iCLK = 1; iRESETn = 1; #50;
iRESETn = 0; #30;               // Active-Low reset 
iRESETn = 1; #(TCLK*2000000);   // 1us * 2000000 = 2 sec
$stop;
end
always    #(TCLK/2)  iCLK = ~iCLK; // TCLK/2 = 500 * 1ns = 0.5us에서 반전 endmodule

▶ 활성화 신호를 생성하는 주파수 분주기 – 행위 수준
module enable_sig (
iCLK,      // 기준 클록
iRESETn,   // Active-Low 리셋 신호
oENSIG);   // 100Hz 활성화 신호
localparam   VAL_CNT = 4'd10;  // 카운트 값을 파라미터 선언 localparam   WIDTH = 4;
input               iCLK, iRESETn;
output  
reg
reg       
oENSIG;
[WIDTH-1:0] cnt_en_100hz;           en_100hz;

assign   oENSIG = en_100hz;
always @ (posedge iCLK or negedge iRESETn)  begin if (!iRESETn) begin 
cnt_en_100hz   <=  0;
en_100hz       <=  0;
end
else if (cnt_en_100hz == VAL_CNT - 1)  begin cnt_en_100hz   <=  0;
en_100hz       <=  1; 
end
else begin
cnt_en_100hz   <=  cnt_en_100hz + 1; en_100hz       <=  0; 
end
end  
endmodule

▶ 활성화 신호를 생성하는 주파수 분주기 – 테스트벤치
`timescale  1us/10ns
module  tb_enable_sig;
localparam   TCLK = 1000;     // TCLK = 1000 * 1us = 1ms
reg             iCLK, iRESETn; wire            oENSIG;
enable_sig U0 (
.iCLK      (iCLK),
.iRESETn   (iRESETn),
.oENSIG    (oENSIG));
initial   begin
iCLK = 1; iRESETn = 1; #700;
iRESETn = 0; #500;         // Active-Low reset 
iRESETn = 1; #(TCLK*50);   // 1ms * 50 = 0.05sec
$stop;
end
always    #(TCLK/2)  iCLK = ~iCLK; // TCLK/2 = 500 * 1us = 0.5ms마다 반전 endmodule


▶ 주파수 분주기
– OSC에서 발생하는 높은 주파수의 클록 펄스로부터 원하는 낮은 주파수의 클록 신호를 생성하는 회로

▶ 기준 클록으로부터 원하는 주파수의 클록을 출력 – 행위 수준
odule freq_div (
iCLK,      // 외부 기준 클록
iRESETn,   // Active-Low 리셋
oMYCLK);   // 원하는 주파수의 클록
localparam   VAL_CNT = 19'd500000;  // 반주기 카운트 값을 파라미터 선언 localparam   WIDTH = 19;
input               iCLK, iRESETn;
output  
reg
oMYCLK;
[WIDTH-1:0] cnt_clk;
reg       
myclk;
assign   oMYCLK = myclk;
always @(posedge iCLK or negedge iRESETn)  begin if (!iRESETn) begin 
cnt_clk   <=  0;
myclk     <=  1;
end
else if (cnt_clk == VAL_CNT - 1)  begin cnt_clk   <=  0;
myclk     <=  ~myclk; 
end
else
cnt_clk   <=  cnt_clk + 1;
end
endmodule

▶ 기준 클록으로부터 원하는 주파수의 클록을 출력 – 테스트벤치
`timescale  1ns/10ps
module  tb_freq_div;
localparam   TCLK = 1000;          // TCLK = 1000 * 1ns = 1us
reg       iCLK, iRESETn;
wire      oMYCLK;
freq_div U0 (
.iCLK      (iCLK), 
.iRESETn
.oMYCLK
(iRESETn),
(oMYCLK));

initial   begin
iCLK = 1; iRESETn = 1; #50;
iRESETn = 0; #30;               // Active-Low reset 
iRESETn = 1; #(TCLK*2000000);   // 1us * 2000000 = 2 sec
$stop;
end
always    #(TCLK/2)  iCLK = ~iCLK; // TCLK/2 = 500 * 1ns = 0.5us에서 반전 endmodule


▶ 활성화 신호를 생성하는 주파수 분주기 – 행위 수준
module enable_sig (
iCLK,      // 기준 클록
iRESETn,   // Active-Low 리셋 신호
oENSIG);   // 100Hz 활성화 신호
localparam   VAL_CNT = 4'd10;  // 카운트 값을 파라미터 선언 localparam   WIDTH = 4;
input               iCLK, iRESETn;
output  
reg
reg       
oENSIG;
[WIDTH-1:0] cnt_en_100hz;           en_100hz;
assign   oENSIG = en_100hz;
always @ (posedge iCLK or negedge iRESETn)  begin if (!iRESETn) begin 
cnt_en_100hz   <=  0;
en_100hz       <=  0;
end
else if (cnt_en_100hz == VAL_CNT - 1)  begin cnt_en_100hz   <=  0;
en_100hz       <=  1; 
end
else begin
cnt_en_100hz   <=  cnt_en_100hz + 1; en_100hz       <=  0; 
end
end  
endmodule

▶ 활성화 신호를 생성하는 주파수 분주기 – 테스트벤치
`timescale  1us/10ns
module  tb_enable_sig;
localparam   TCLK = 1000;     // TCLK = 1000 * 1us = 1ms
reg             iCLK, iRESETn; wire            oENSIG;
enable_sig U0 (
.iCLK      (iCLK),
.iRESETn   (iRESETn),
.oENSIG    (oENSIG));
initial   begin
iCLK = 1; iRESETn = 1; #700;
iRESETn = 0; #500;         // Active-Low reset 
iRESETn = 1; #(TCLK*50);   // 1ms * 50 = 0.05sec
$stop;
end
always    #(TCLK/2)  iCLK = ~iCLK; // TCLK/2 = 500 * 1us = 0.5ms마다 반전 endmodule

6 7-세그먼트 디코더
▶ 7-세그먼트 디코더
– 숫자(digit) 7개, 소수점(dot point) 1개로 구성된 출력장치 – 발광 다이오드의 배열
– 단자: 애노드(anode), 캐소드(cathod)
▶ 7-세그먼트 디코더
– 공통 양극 방식(CA), 공통 음극 방식(CC) – a, b, c, d, e, f, g, dp

▶ CC-type 4자리 7-세그먼트 제어기 모듈 – 행위 수준
module fnd_controler (
iCLK,         // 클록 신호
iRESETn,      // Active-Low 리셋
iBCD,         // 디코더의 BCD 입력
oCOM_FND,     // FND의 공통 단자(출력)
oDATA_FND);   // 7-세그먼트 표시장치의 제어신호
input           iCLK, iRESETn; input     [3:0] iBCD; output    [3:0] oCOM_FND; output    [7:0] oDATA_FND; reg       [7:0] data_fnd;

always @ (posedge iCLK or negedge iRESETn) begin data_fnd <= 8'b1111_1111;
else
case(iBCD) 
// FND 제어신호(0일 때 ON),  abcd_efgdp, 4'd0    :  data_fnd   <=   8'b1111_1100; 4'd1    :  data_fnd   <=   8'b0110_0000; 4'd2    :  data_fnd   <=   8'b1101_1010; 4'd3    :  data_fnd   <=   8'b1111_0010; 4'd4    :  data_fnd   <=   8'b0110_0110; 4'd5    :  data_fnd   <=   8'b1011_0110; 4'd6    :  data_fnd   <=   8'b1011_1110; 4'd7    :  data_fnd   <=   8'b1110_0100; 4'd8    :  data_fnd   <=   8'b1111_1110; 4'd9    :  data_fnd   <=   8'b1110_0110; default :  data_fnd   <=   8'b1111_1111;
endcase
end

assign oCOM_FND = 4'b0000; 
assign oDATA_FND= data_fnd;
endmodule


▶ CC-type 4자리 7-세그먼트 제어기 모듈 – 테스트벤치
`timescale  1ns/10ps
module  tb_fnd_controler;   
localparam   TCLK = 100;     // TCLK = 100 * 1ns = 100ns
reg         iCLK, iRESETn;
reg   [3:0] iBCD;
wire  [3:0] oCOM_FND;
wire  [7:0] oDATA_FND;
integer     i;
fnd_controler U0 (
.iCLK        (iCLK), 
.iRESETn     (iRESETn),
.iBCD        (iBCD),
.oCOM_FND (oCOM_FND),
.oDATA_FND (oDATA_FND));



▶ CC-type 4자리 7-세그먼트 제어기 모듈 – 테스트벤치
initial   begin
iCLK = 1; iRESETn = 1; iBCD = 4'd0; #(TCLK/2);
iRESETn = 0; #(TCLK/2);   // Active-Low reset
iRESETn = 1; 
for (i = 0; i < 11; i = i + 1) begin
#(TCLK);
if (iBCD == 9)
iBCD = 4'b0;
else
iBCD = iBCD + 4'd1;
end
$stop;
end
always   #(TCLK/2) iCLK = ~iCLK; // 50n에서 반전, 10M
Hz 클록 생성
endmodule


▶ 다음 CC-type 7-세그먼트를 이용한 4자리 BCD 카운터의 최상 위 모듈을 설게 해보자.
▶ CC-type 7-세그먼트를 이용한 4자리 BCD 카운터의 최상위 모 듈 – 구조적 방법
module  counter_4digit (
iCLK,        // 1MHz 기준 클록
iRESETn,     // Active-Low reset 
oDATA_FND,   // FND 표시를 위한 8비트 데이터 출력 데이터
oCOM_FND);   // FND 자릿수 선택을 위한 공통 단자, 4비트 출력신호
input           iCLK, iRESETn;     
output   [7:0]  oDATA_FND;   // FND 표시를 위한 제어신호(a ~ dp) 데이터 output   [3:0]  oCOM_FND;
wire   
         en_200;     // FND 선택을 위한 200Hz enable 신호
wire   
         en_1;       // BCD 증가 카운터를 위한 1Hz enable 신호
wire   
  [15:0] data_cnt;   // BCD 증가 카운터의 계수(counting) 값

freq_div_fnd  UFD (
.iCLK      (iCLK),
.iRESETn   (iRESETn), 
.oEN_200   (en_200),
.oEN_1     (en_1));
bcd_cnt  UBCD (
.iCLK        (iCLK),
.iRESETn     (iRESETn),
.iEN_1       (en_1),
.oDATA_CNT   (data_cnt));
drv_fnd4  UDRV (
.iCLK        (iCLK),
.iRESETn     (iRESETn),
.iEN_200     (en_200),
.iBCD        (data_cnt),
.oCOM_FND    (oCOM_FND),
.oDATA_FND   (oDATA_FND)); endmodule

▶ 원하는 주파수의 활성화 신호를 생성하는 주파수 분주기
module freq_div_fnd (
iCLK,      // 1MHz 기준 클록
iRESETn,   // Active-Low reset
oEN_200,   // 200Hz 활성화 신호
oEN_1);    // 1Hz 활성화 신호
localparam VAL_CNT200 = 13'd5000;    // 카운트 값을 파라미터 선언 localparam VAL_CNT1 = 20'd1000000;  // 카운트 값을 파라미터 선언
input           iCLK, iRESETn; output          oEN_200;
output          oEN_1;
reg      [12:0] cnt_en_200; // 200Hz 활성화 신호 생성을 위한 카운터 reg      [19:0] cnt_en_1;   // 1hz 활성화 신호 생성을 위한 카운터 reg             en_200;     // 200Hz 활성화 신호
reg             en_1;       // 1Hz 활성화 신호

▶ 원하는 주파수의 활성화 신호를 생성하는 주파수 분주기
// 1. Frequency divider(1MHz → 200Hz) : FND의 com 선택을 위한 enable signal // 2. Frequency divider(1MHz → 1Hz) : BCD 카운터를 위한 enable signal
assign   oEN_200 = en_200;
assign   oEN_1 = en_1;
endmodule

▶ 원하는 주파수의 활성화 신호를 생성하는 주파수 분주기 1
// 1. Frequency divider(1MHz → 200Hz) : FND의 com 선택을 위한 enable signal always @ (posedge iCLK or negedge iRESETn)  begin
if (!iRESETn)  begin    // 비동기 리셋
cnt_en_200   <= 0;   // cnt_en_200는 리셋(low, 0) 
en_200       <= 0;   // en_200는 리셋(low, 0)
end
else if (cnt_en_200 == VAL_CNT200 - 1) begin // 1us*5,000 = 0.005sec cnt_en_200   <=  0;  // 0.005초마다 cnt_en_200는 low(0)로 리셋 en_200       <=  1;  // 0.005초마다 en_200는 1us 동안 high(1)로 셋
end
else begin
cnt_en_200   <=  cnt_en_200 + 1'b1;
en_200       <=  0;  // en_200hz 신호 low(0) 유지
end
end

▶ 원하는 주파수의 활성화 신호를 생성하는 주파수 분주기 2
// 2. Frequency divider(1MHz → 1Hz) : BCD 카운터를 위한 enable signal always @ (posedge iCLK or negedge iRESETn)  begin
if (!iRESETn)  begin    // 비동기 리셋
cnt_en_1     <= 0;   // cnt_en_1은 리셋(low, 0)
en_1         <= 0;   // en_200는 리셋(low, 0)
end
else if (cnt_en_1 == VAL_CNT1 - 1)  begin  // 1us * 1,000,000 = 1sec cnt_en_1     <= 0;   // 1초마다 cnt_en_1은 low(0)로 리셋
en_1         <= 1;   // 1초마다 en_1은 1us 동안 high(1)로 셋
end
else begin
cnt_en_1     <= cnt_en_1 + 1'b1; en_1         <= 0;          
end
end


▶ 4자리 BCD 증가 카운터
– 1MHz 기준 클록에 동기 되어 1Hz 주파수의 활성화 신호가 High(1)일 때 1씩 증가하는 BCD 카운터

▶ 4자리 BCD 증가 카운터
module bcd_cnt (
iCLK,         // 1MHz 기준 클록
iRESETn,      // Active-Low reset
iEN_1,        // 1Hz Enable 신호
oDATA_CNT);   // 4자릿수 BCD 카운터의 계수값(16비트)
input           iCLK, iRESETn; input           iEN_1;     
output 
reg      
  [15:0] oDATA_CNT;   
[3:0]  arr_cnt [3:0];  // 4비트 벡터 4개로 구성된 4x4 배열
always @ (posedge iCLK or negedge iRESETn)  begin
if (!iRESETn) begin   // 비동기식 4자리 BCD 카운터의 리셋
arr_cnt[0] <= 0;   // 일의 자리 BCD 카운터 값
arr_cnt[1] <= 0;   // 십의 자리 BCD 카운터 값
arr_cnt[2] <= 0;   // 백의 자리 BCD 카운터 값
arr_cnt[3] <= 0;   // 천의 자리 BCD 카운터 값
end
else if (iEN_1 == 1)  // 1. clk에 동기된 1Hz 신호로 BCD 카운터값 증가 // 2. FND에 표시할 BCD 카운트 값: 천의 자리, 백의 자리, 십의 자리, 일의 자리
endmodule
else if (iEN_1 == 1)  // 1. clk에 동기된 1Hz 신호로 BCD 카운터값 증가 casex({arr_cnt[3], arr_cnt[2], arr_cnt[1], arr_cnt[0]})
{4'h9, 4'h9, 4'h9, 4'h9} :  begin  // 4자릿수 카운터값 = 9999 arr_cnt[3] <= 0;
arr_cnt[2] <= 0;
arr_cnt[1] <= 0;
arr_cnt[0] <= 0;
end
{4'hx, 4'h9, 4'h9, 4'h9} :  begin  // 4자릿수 카운터값 = x999 arr_cnt[3] <= arr_cnt[3] + 4'h1;
arr_cnt[2] <= 0;
arr_cnt[1] <= 0;
arr_cnt[0] <= 0;
end
{4'hx, 4'hx, 4'h9, 4'h9} :  begin  // 4자릿수 카운터값 = xx99 arr_cnt[3] <= arr_cnt[3];
arr_cnt[2] <= arr_cnt[2] + 4'h1;
arr_cnt[1] <= 0;
arr_cnt[0] <= 0;
end
{4'hx, 4'hx, 4'hx, 4'h9} :  begin  // 4자릿수 카운터값 = xxx9 arr_cnt[3] <= arr_cnt[3];
arr_cnt[2] <= arr_cnt[2]; arr_cnt[1] <= arr_cnt[1] + 4'h1; arr_cnt[0] <= 0;
end
default                  :  begin arr_cnt[3] <= arr_cnt[3];
arr_cnt[2] <= arr_cnt[2];
arr_cnt[1] <= arr_cnt[1]; arr_cnt[0] <= arr_cnt[0] + 4'h1;
end
endcase
else begin
arr_cnt[3] <= arr_cnt[3]; arr_cnt[2] <= arr_cnt[2]; arr_cnt[1] <= arr_cnt[1]; arr_cnt[0] <= arr_cnt[0];
end
end
// 2. FND에 표시할 BCD 카운트 값: 천의 자리, 백의 자리, 십의 자리, 일의 자리 assign oDATA_CNT = {arr_cnt[3], arr_cnt[2], arr_cnt[1], arr_cnt[0]};  
endmodule

▶ 4자리 7-세그먼트 제어기
– 1MHz 기준 클록에 동기 되어 200Hz 주파수의 활성화 신호에 의한 잔상효 과를 사용하여 서로 다른 4자리 숫자를 표시할 수 있는 모듈

▶ 4자리 7-세그먼트 제어기
module drv_fnd4 (
iCLK,        // 1MHz 클록 신호
iRESETn,     // Active-Low reset
iEN_200,     // 200Hz 활성화 신호
iBCD,        // 4자리 BCD 카운터의 계수값 oCOM_FND,    // FND의 공통 단자(출력)
oDATA_FND);  // 7-세그먼트 표시장치의 제어신호
input           iCLK, iRESETn;
input           iEN_200;
input    [15:0] iBCD;
output   [3:0]  oCOM_FND;
output   [7:0]  oDATA_FND;

reg      [1:0]  sel_cnt;
reg      [3:0]  bcd;
reg      [3:0]  com_fnd;
reg      [7:0]  data_fnd;

▶ 4자리 7-세그먼트 제어기
// 1. 7-세그먼트 자릿수 선택을 위한 카운터 always @ (posedge iCLK or negedge iRESETn)  begin
if (!iRESETn)                
sel_cnt <= 2'b00;
else if (iEN_200 == 1)  
sel_cnt <= sel_cnt + 2'b01; 
else
sel_cnt <= sel_cnt;
end

// 2. 자릿수 선택 카운터의 계수값에 다른 7-세그먼트 공통 단자 선택 always @ (posedge iCLK or negedge iRESETn)  begin
if(!iRESETn)              
com_fnd <= 4'b0000;
else
case(sel_cnt)      
2'd0 : com_fnd <= 4'b1110;    // 일의 자리 FND 선택 2'd1 : com_fnd <= 4'b1101;    // 십의 자리 FND 선택 2'd2 : com_fnd <= 4'b1011;    // 백의 자리 FND 선택 2'd3 : com_fnd <= 4'b0111;    // 천의 자리 FND 선택 default : com_fnd <= 4'b1111; // Otherwise
endcase
end
// 3. 선택한 자릿수에 표시할 BCD 카운터의 계수값
always @ (posedge iCLK or negedge iRESETn)  begin
if (!iRESETn)              
bcd <= 4'b0000;
else
case(sel_cnt)
2'd0 : bcd <= iBCD[3:0];   // 일의 자리 FND에 표시할 계수값 2'd1 : bcd <= iBCD[7:4];   // 십의 자리 FND에 표시할 계수값 2'd2 : bcd <= iBCD[11:8];  // 백의 자리 FND에 표시할 계수값 2'd3 : bcd <= iBCD[15:12]; // 천의 자리 FND에 표시할 계수값 default : bcd <= 4'b0;     // Otherwise
endcase
end

// 4. 7-세그먼트 디코더(CC-Type)    
always @ (posedge iCLK or negedge iRESETn) begin if (!iRESETn)
data_fnd <= 8'b1111_1111;
else
case(bcd) 
// FND 제어신호(0일 때 ON),  abcd_efgdp, 
4'd0    :  data_fnd =   8'b1111_1100;
4'd1    :  data_fnd =   8'b0110_0000;
4'd2    :  data_fnd =   8'b1101_1;
4'd3  :  data_fnd =   8'b1111_0010;
4'd4  :  data_fnd =   8'b0110_0110;
4'd5  :  data_fnd =   8'b1011_0110;
4'd6   :  data_fnd =   8'b1011_1110;
4'd7  :  data_fnd =   8'b1110_0100;
4'd8   :  data_fnd =   8'b1111_1110;
4'd9  :  data_fnd =   8'b1110_0110;
default :  data_fnd =   8'b1111_1111;
endcase
end
  
// 4. 7-세그먼트 디코더(CC-Type)    
assign   oCOM_FND = com_fnd; assign   oDATA_FND = data_fnd;
endmodule

▶ 4자리 7-세그먼트 제어기 – 테스트벤치
`timescale  100ns/10ns
module tb_counter_4digit;   
localparam   TCLK = 10;     // TCLK = 10 * 100ns = 1us reg         iCLK, iRESETn;
wire  [7:0] oDATA_FND;
wire  [3:0] oCOM_FND;
counter_4digit TOP (
.iCLK        (iCLK), 
.iRESETn     (iRESETn),
.oDATA_FND   (oDATA_FND),
.oCOM_FND    (oCOM_FND));
initial   begin
iCLK = 1; iRESETn = 1; #(TCLK/2);
iRESETn = 0; #(TCLK/2);         // Active-Low reset iRESETn = 1; #(TCLK*5000000);   // 1us * 5,000,000 = 5sec     
$stop;
end
always   #(TCLK/2) iCLK = ~iCLK;   // 0.5us마다 반전, 1MHz endmodule




7 유한상태머신

▶ 유한상태머신
– 정해진 수의 상태를 가지고 있어서 클록의 이벤트에 따라 상태 변화와 해 당 상태의 출력을 생성하는 회로
– 정해진 순서를 따름, 단일 클록 구동,특별한 순서로 반응하는 출력 – 상태도, 상태표
– 밀리, 무어

▶ 유한상태머신
– 밀리, 무어





