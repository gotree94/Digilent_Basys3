# 🧩 Digilent Basys3 Verilog 순차회로 모델링

## 🎯 학습목표
- 모델링의 기본 단위인 **모듈**을 이해한다.  
- 대표적인 **순차회로**를 모델링할 수 있다.  
- **유한상태머신(FSM)** 의 개념을 이해한다.  
- **Mealy FSM** 과 **Moore FSM** 의 차이를 이해한다.  
- Mealy/Moore FSM을 **Verilog**로 모델링할 수 있다.  

---

## 📚 목차
1. [순차회로 개요](#1-순차회로combinational-circuit)
2. [래치와 플립플롭](#2-래치와-플립플롭)
3. [시프트 레지스터](#3-시프트-레지스터)
4. [카운터](#4-카운터)
5. [주파수 분주기](#5-주파수-분주기)
6. [7-세그먼트 디코더/드라이버](#6-7-세그먼트-디코더)
7. [유한상태머신(FSM)](#7-유한상태머신)

---

## 1. 순차회로(Combinational circuit)

### ▶ 순차회로
- 시간의 흐름에 따라 **상태(state)** 가 변함  
- 상태는 **과거 상태 + 현재 입력**의 조합으로 결정  
- **기억소자 O** (상태 레지스터, 카운터, 타이머)

### ▶ 동기식 순차회로
- **클록의 엣지**에서만 상태 전이  
- 명확한 시간 간격에 따라 출력이 변함

### ▶ 비동기식 순차회로
- 클록과 무관하게 **임의 시점의 입력**을 반영

### ▶ 클록(Clock) & 펄스(Pulse)
- 레벨(level): High/Low의 안정 구간  
- 엣지(edge): 레벨 변화 시점 (↑/↓)  
- 듀티사이클: 한 주기 중 High의 비율

---

## 2. 래치와 플립플롭

### ▶ 래치(Latch) vs 플립플롭(Flip-Flop)
- **래치**: 레벨 감지, 비동기식 (SR, D)  
- **플립플롭**: 엣지 감지, 동기식 (D, JK 등)

### 💻 D Latch
```verilog
module dlatch(input G, input d, output reg q);
  always @(G or d) begin
    if (G) q <= d;
    else   q <= q;
  end
endmodule
```

#### 🧪 D Latch Testbench
```verilog
`timescale 1ns/1ps
module tb_dlatch;
  reg clk, d;
  wire q;
  dlatch U0(.G(clk), .d(d), .q(q));

  initial begin
    clk = 1'b0;
    forever #10 clk = ~clk;
  end

  initial begin
    d = 0;
    #15 d = 1;  #20 d = 0; #10 d = 1; #10 d = 0; #10 d = 1; #15 d = 0;
  end
endmodule
```

### 💻 D Flip-Flop (안티패턴 vs 권장)
안티패턴: q_bar까지 같은 `always` 블록에서 갱신 → **불필요한 FF 증가**
```verilog
module d_ff_bad1(input clk, input d, output reg q, output reg q_bar);
  always @(posedge clk) begin
    q     <= d;
    q_bar <= ~d;
  end
endmodule
```

권장: `q_bar`는 `assign`으로 외부에서 생성
```verilog
module d_ff_good(input clk, input d, output reg q, output q_bar);
  assign q_bar = ~q;
  always @(posedge clk) q <= d;
endmodule
```

### 💻 D-FF (비동기 클리어/프리셋 포함) – if + 논블록킹
```verilog
module d_ff(
  input iCLK, input iCLEARn, input iPRESETn,
  input iD, output reg oQ, output oQn
);
  assign oQn = ~oQ;
  always @(posedge iCLK or negedge iCLEARn or negedge iPRESETn) begin
    if (!iCLEARn)      oQ <= 1'b0;
    else if (!iPRESETn)oQ <= 1'b1;
    else               oQ <= iD;
  end
endmodule
```

#### 🧪 D-FF Testbench
```verilog
`timescale 1ns/1ps
module tb_d_ff;
  reg iCLK, iCLEARn, iPRESETn, iD;
  wire oQ, oQn;

  d_ff U0(.iCLK(iCLK), .iCLEARn(iCLEARn), .iPRESETn(iPRESETn), .iD(iD), .oQ(oQ), .oQn(oQn));

  initial begin
    iCLK = 0;
    forever #50 iCLK = ~iCLK;
  end

  initial begin
    iCLEARn = 1; iPRESETn = 1; iD = 0; #50;
    iCLEARn = 0; #30;                   // clear
    iCLEARn = 1; iPRESETn = 0; #30;     // preset
    iPRESETn = 1; iD = 0; #100;
    iD = 1; #100; iD = 0; #100; iD = 1; #100; iD = 0; #100; 
    $stop;
  end
endmodule
```

### 💻 JK-FF – 게이트 프리미티브 기반(D로 구성)
```verilog
module jk_ff(
  input iCLK, input iCLEARn, input iPRESETn,
  input iJ, input iK, output oQ, output oQn
);
  wire w0, w1, w2, w3;
  not  U0(w0, iK);
  nand U1(w1, oQn, iJ);
  nand U2(w2, w0, oQ);
  nand U3(w3, w1, w2);
  d_ff UDFF(.iCLK(iCLK), .iCLEARn(iCLEARn), .iPRESETn(iPRESETn), .iD(w3), .oQ(oQ), .oQn(oQn));
endmodule
```

### 💻 JK-FF – if + 논블록킹
```verilog
module jk_ff_bhv(
  input iCLK, input iCLEARn, input iPRESETn,
  input iJ, input iK, output reg oQ, output oQn
);
  assign oQn = ~oQ;
  always @(posedge iCLK or negedge iCLEARn or negedge iPRESETn) begin
    if(!iCLEARn)       oQ <= 1'b0;
    else if(!iPRESETn) oQ <= 1'b1;
    else
      case({iJ,iK})
        2'b00: oQ <= oQ;      // hold
        2'b01: oQ <= 1'b0;    // reset
        2'b10: oQ <= 1'b1;    // set
        2'b11: oQ <= ~oQ;     // toggle
      endcase
  end
endmodule
```

#### 🧪 JK-FF Testbench
```verilog
`timescale 1ns/1ps
module tb_jk_ff;
  reg iCLK, iCLEARn, iPRESETn, iJ, iK;
  wire oQ, oQn;

  jk_ff_bhv U0(.iCLK(iCLK), .iCLEARn(iCLEARn), .iPRESETn(iPRESETn), .iJ(iJ), .iK(iK), .oQ(oQ), .oQn(oQn));

  initial begin
    iCLK = 0; forever #50 iCLK = ~iCLK;
  end

  initial begin
    iCLEARn = 1; iPRESETn = 1; iJ = 0; iK = 0; #50;
    iCLEARn = 0; #30;                       // reset
    iCLEARn = 1; iPRESETn = 0; #30;         // preset
    iPRESETn = 1;
    iJ=0;iK=1; #100;  // reset
    iJ=0;iK=0; #100;  // hold
    iJ=1;iK=0; #100;  // set
    iJ=0;iK=0; #100;  // hold
    iJ=0;iK=1; #100;  // reset
    iJ=0;iK=0; #100;  // hold
    iJ=1;iK=1; #200;  // toggle
    $stop;
  end
endmodule
```

---

## 3. 시프트 레지스터

### ▶ 개요
- 직렬/병렬 입출력: **SISO, SIPO, PISO, PIPO**  
- 버퍼, 시간지연, 되먹임 구조 등

### 💻 SIPO – 조건연산자
```verilog
module sipo(input iCLK, input iRESETn, input iS, output [3:0] oP);
  reg [3:0] p_out;
  assign oP = p_out;
  always @(posedge iCLK or negedge iRESETn) begin
    if (!iRESETn) p_out <= 4'b0;
    else          p_out <= {p_out[2:0], iS};
  end
endmodule
```

### 💻 SIPO – if
```verilog
module sipo_if(input iCLK, input iRESETn, input iS, output [3:0] oP);
  reg [3:0] p_out; assign oP = p_out;
  always @(posedge iCLK or negedge iRESETn) begin
    if (!iRESETn) p_out <= 4'b0;
    else begin
      p_out <= (p_out << 1);
      p_out[0] <= iS;
    end
  end
endmodule
```

### 🧪 SIPO Testbench
```verilog
`timescale 1ns/10ps
module tb_sipo;
  reg iCLK, iRESETn, iS;
  wire [3:0] oP;
  sipo U0(.iCLK(iCLK), .iRESETn(iRESETn), .iS(iS), .oP(oP));

  initial begin
    iCLK = 0; forever #50 iCLK = ~iCLK;
  end

  initial begin
    iRESETn = 1; iS = 0; #100;
    iRESETn = 0; #30;  // reset
    iRESETn = 1;
    iS=0; #100; iS=0; #100; iS=1; #100; iS=0; #100; iS=0; #100; iS=1; #100;
    $stop;
  end
endmodule
```

### 💻 PISO – 조건연산자
```verilog
module piso(input iCLK, input iRESETn, input iLOADn, input [3:0] iP, output oS);
  reg [3:0] q_ff;
  always @(posedge iCLK or negedge iRESETn or negedge iLOADn) begin
    if (!iRESETn)       q_ff <= 4'b0;
    else if (!iLOADn)   q_ff <= iP;
    else                q_ff <= {q_ff[2:0], 1'b0};
  end
  assign oS = q_ff[3];
endmodule
```

### 💻 PISO – if
```verilog
module piso_if(input iCLK, input iRESETn, input iLOADn, input [3:0] iP, output oS);
  reg [3:0] q_ff; assign oS = q_ff[3];
  always @(posedge iCLK or negedge iRESETn or negedge iLOADn) begin
    if (!iRESETn)     q_ff <= 4'b0;
    else if (!iLOADn) q_ff <= iP;
    else begin
      q_ff <= (q_ff << 1);
      q_ff[0] <= 1'b0;
    end
  end
endmodule
```

---

## 4. 카운터

### ▶ 분류
- 동기/비동기, 2진/10진, 증가/감소 등

### 💻 비동기식 4비트 2진 증가 카운터 (Ripple) – 행위수준
```verilog
module ripple_upcnt(input iCLK, input iRESETn, output [3:0] oQ);
  reg [3:0] qout; assign oQ = qout;
  always @(negedge iCLK or negedge iRESETn) begin
    if (!iRESETn) qout[0] <= 1'b0; else qout[0] <= ~qout[0];
  end
  always @(negedge qout[0] or negedge iRESETn) begin
    if (!iRESETn) qout[1] <= 1'b0; else qout[1] <= ~qout[1];
  end
  always @(negedge qout[1] or negedge iRESETn) begin
    if (!iRESETn) qout[2] <= 1'b0; else qout[2] <= ~qout[2];
  end
  always @(negedge qout[2] or negedge iRESETn) begin
    if (!iRESETn) qout[3] <= 1'b0; else qout[3] <= ~qout[3];
  end
endmodule
```

#### 🧪 Ripple Counter TB
```verilog
`timescale 1ns/10ps
module tb_ripple_upcnt;
  reg iCLK, iRESETn; wire [3:0] oQ;
  ripple_upcnt U0(.iCLK(iCLK), .iRESETn(iRESETn), .oQ(oQ));
  initial iCLK = 0;
  always #50 iCLK = ~iCLK;
  initial begin
    iRESETn = 1; #100; iRESETn = 0; #100; iRESETn = 1; #2000; $stop;
  end
endmodule
```

### 💻 동기식 4비트 증가/감소 카운터 – 행위수준
```verilog
module sync_cnt(input iCLK, input iRESETn, input iSEL, output [3:0] oQ);
  reg [3:0] qout; assign oQ = qout;
  always @(posedge iCLK or negedge iRESETn) begin
    if (!iRESETn) qout <= 4'b0;
    else case(iSEL)
      1'b0: qout <= qout - 1; // down
      1'b1: qout <= qout + 1; // up
    endcase
  end
endmodule
```

#### 🧪 Sync Counter TB
```verilog
`timescale 1ns/10ps
module tb_sync_cnt;
  reg iCLK, iRESETn, iSEL; wire [3:0] oQ;
  sync_cnt U0(.iCLK(iCLK), .iRESETn(iRESETn), .iSEL(iSEL), .oQ(oQ));
  initial iCLK = 1; always #50 iCLK = ~iCLK;
  initial begin
    iRESETn = 1; iSEL = 1; #60;
    iRESETn = 0; #80;
    iRESETn = 1; iSEL = 1; #1500;
    iSEL = 0; #1500;
    $stop;
  end
endmodule
```

### 💻 BCD(0~9) 카운터 – 행위수준
```verilog
module sync_bcd_cnt(input iCLK, input iRESETn, output [3:0] oBCD);
  reg [3:0] bcd; assign oBCD = bcd;
  always @(posedge iCLK or negedge iRESETn) begin
    if (!iRESETn) bcd <= 4'b0;
    else if (bcd < 4'd9) bcd <= bcd + 1;
    else bcd <= 4'd0;
  end
endmodule
```

---

## 5. 주파수 분주기

### 💻 분주기 – 원하는 주파수 생성
```verilog
module freq_div #(parameter WIDTH=19, parameter VAL_CNT=19'd500000)
 (input iCLK, input iRESETn, output oMYCLK);
  reg [WIDTH-1:0] cnt_clk; reg myclk; assign oMYCLK = myclk;
  always @(posedge iCLK or negedge iRESETn) begin
    if (!iRESETn) begin cnt_clk <= 0; myclk <= 1'b1; end
    else if (cnt_clk == VAL_CNT-1) begin cnt_clk <= 0; myclk <= ~myclk; end
    else cnt_clk <= cnt_clk + 1'b1;
  end
endmodule
```

#### 🧪 분주기 TB
```verilog
`timescale 1ns/10ps
module tb_freq_div;
  localparam TCLK = 1000;
  reg iCLK, iRESETn; wire oMYCLK;
  freq_div U0(.iCLK(iCLK), .iRESETn(iRESETn), .oMYCLK(oMYCLK));
  initial begin
    iCLK = 1; iRESETn = 1; #50;
    iRESETn = 0; #30;
    iRESETn = 1; #(TCLK*2000000);
    $stop;
  end
  always #(TCLK/2) iCLK = ~iCLK;
endmodule
```

### 💻 Enable 신호 생성기 (예: 1Hz/200Hz 펄스)
```verilog
module enable_sig #(parameter WIDTH=4, parameter VAL_CNT=10)
 (input iCLK, input iRESETn, output oENSIG);
  reg [WIDTH-1:0] cnt; reg en; assign oENSIG = en;
  always @(posedge iCLK or negedge iRESETn) begin
    if(!iRESETn) begin cnt <= 0; en <= 1'b0; end
    else if (cnt == VAL_CNT-1) begin cnt <= 0; en <= 1'b1; end
    else begin cnt <= cnt + 1'b1; en <= 1'b0; end
  end
endmodule
```

---

## 6. 7-세그먼트 디코더

### 💻 단일 자리 CC형 디코더
```verilog
module fnd_decoder_cc(input [3:0] iBCD, output reg [7:0] oDATA_FND);
  // abcd_efgdp (0이면 LED ON) – CC형
  always @* begin
    case (iBCD)
      4'd0: oDATA_FND = 8'b1111_1100;
      4'd1: oDATA_FND = 8'b0110_0000;
      4'd2: oDATA_FND = 8'b1101_1010;
      4'd3: oDATA_FND = 8'b1111_0010;
      4'd4: oDATA_FND = 8'b0110_0110;
      4'd5: oDATA_FND = 8'b1011_0110;
      4'd6: oDATA_FND = 8'b1011_1110;
      4'd7: oDATA_FND = 8'b1110_0100;
      4'd8: oDATA_FND = 8'b1111_1110;
      4'd9: oDATA_FND = 8'b1110_0110;
      default: oDATA_FND = 8'b1111_1111;
    endcase
  end
endmodule
```

### 💻 4자리 CC형 드라이버 (200Hz 다중화)
```verilog
module drv_fnd4(input iCLK, input iRESETn, input iEN_200,
                input [15:0] iBCD, output [3:0] oCOM_FND, output [7:0] oDATA_FND);
  reg [1:0] sel;
  reg [3:0] bcd;
  reg [3:0] com;
  wire [7:0] data;

  always @(posedge iCLK or negedge iRESETn) begin
    if (!iRESETn) sel <= 2'b00;
    else if (iEN_200) sel <= sel + 2'b01;
  end

  always @* begin
    case (sel)
      2'd0: begin com = 4'b1110; bcd = iBCD[3:0];   end
      2'd1: begin com = 4'b1101; bcd = iBCD[7:4];   end
      2'd2: begin com = 4'b1011; bcd = iBCD[11:8];  end
      2'd3: begin com = 4'b0111; bcd = iBCD[15:12]; end
    endcase
  end

  fnd_decoder_cc DEC(.iBCD(bcd), .oDATA_FND(data));

  assign oCOM_FND  = com;
  assign oDATA_FND = data;
endmodule
```

### 💻 4자리 BCD 카운터 + 드라이버 Top
```verilog
module counter_4digit(input iCLK, input iRESETn,
                      output [7:0] oDATA_FND, output [3:0] oCOM_FND);
  wire en_200, en_1;
  wire [15:0] bcd_cnt;

  // 분주기 (예: 1MHz 기준에서 파라미터 조정 필요)
  enable_sig #(.WIDTH(13), .VAL_CNT(5000)) EN200 (.iCLK(iCLK), .iRESETn(iRESETn), .oENSIG(en_200));
  enable_sig #(.WIDTH(20), .VAL_CNT(1000000)) EN1 (.iCLK(iCLK), .iRESETn(iRESETn), .oENSIG(en_1));

  // 4자리 BCD 카운터 (1Hz 증가)
  bcd_cnt4 U_CNT(.iCLK(iCLK), .iRESETn(iRESETn), .iEN_1(en_1), .oDATA_CNT(bcd_cnt));

  // 드라이버
  drv_fnd4 U_DRV(.iCLK(iCLK), .iRESETn(iRESETn), .iEN_200(en_200),
                 .iBCD(bcd_cnt), .oCOM_FND(oCOM_FND), .oDATA_FND(oDATA_FND));
endmodule

module bcd_cnt4(input iCLK, input iRESETn, input iEN_1, output [15:0] oDATA_CNT);
  reg [3:0] d3, d2, d1, d0; // 천,백,십,일
  assign oDATA_CNT = {d3,d2,d1,d0};
  always @(posedge iCLK or negedge iRESETn) begin
    if (!iRESETn) {d3,d2,d1,d0} <= 16'h0000;
    else if (iEN_1) begin
      if      ({d3,d2,d1,d0} == {4'd9,4'd9,4'd9,4'd9}) {d3,d2,d1,d0} <= 16'h0000;
      else if ({d2,d1,d0} == {4'd9,4'd9,4'd9}) begin d3 <= d3 + 1; d2<=0; d1<=0; d0<=0; end
      else if ({d1,d0} == {4'd9,4'd9})         begin d2 <= d2 + 1; d1<=0; d0<=0;       end
      else if (d0 == 4'd9)                     begin d1 <= d1 + 1; d0<=0;              end
      else                                     d0 <= d0 + 1;
    end
  end
endmodule
```

---

## 7. 유한상태머신

### ▶ 개념
- 유한 개수의 **상태**와 **전이**로 구성, **클록 이벤트**에 따라 전이 및 출력 발생  
- **Mealy**: 출력이 *상태+입력*에 의존  
- **Moore**: 출력이 *상태*에만 의존

### 💻 예시: Moore FSM (3-state)
```verilog
module fsm_moore(input iCLK, input iRESETn, input x, output reg y);
  typedef enum reg [1:0] {S0=2'd0, S1=2'd1, S2=2'd2} state_t;
  state_t cs, ns;

  always @(posedge iCLK or negedge iRESETn) begin
    if (!iRESETn) cs <= S0;
    else cs <= ns;
  end

  always @* begin
    case (cs)
      S0: ns = x ? S1 : S0;
      S1: ns = x ? S2 : S0;
      S2: ns = x ? S2 : S1;
      default: ns = S0;
    endcase
  end

  always @* begin
    case (cs)
      S0: y = 1'b0;
      S1: y = 1'b0;
      S2: y = 1'b1;
    endcase
  end
endmodule
```

> 필요하면 Mealy 버전과 테스트벤치도 추가해 드릴게요.

---

### ✅ 팁
- 순차회로에서는 **논블록킹(`<=`)** 사용이 기본입니다.  
- 비동기 리셋은 **민감도 목록에 `negedge iRESETn`** 을 포함하세요.  
- `q_bar` 등 **보조 출력**은 가능하면 `assign`으로 파생하세요.  
- 시험/실습을 위해 항상
  ```verilog
  `timescale 1ns/1ps
  `default_nettype none
  ```
  습관화!
