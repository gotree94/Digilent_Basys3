# 🧩 Digilent Basys3 Verilog 응용회로 모델링

## 🎯 학습목표
- 디지털 시스템에서 사용되는 기본적인 **응용회로**를 이해한다.  
- **푸시버튼 디바운스** 입력회로를 모델링할 수 있다.  
- **Text LCD**를 제어하는 출력회로를 모델링할 수 있다.  
- 대표적 직렬 통신인 **UART** 회로를 모델링할 수 있다.  
- 간단한 **디지털 필터**(FIR/IIR)를 모델링할 수 있다.  

---

## 📚 목차
1. [푸시버튼을 이용한 입력회로](#1-푸시버튼을-이용한-입력회로)  
2. [텍스트 LCD](#2-텍스트-lcd)  
3. [UART 통신](#3-uart-통신)  
4. [디지털 필터](#4-디지털-필터)  

---

## 1. 푸시버튼을 이용한 입력회로

### ▶ 스위치와 디바운싱
- 스위치는 on/off를 통해 디지털 입력을 제공하지만 **chattering/bounce**로 인해 짧은 시간동안 0/1이 빠르게 흔들린다.  
- **디바운싱**은 이 고주파 잡음을 제거하는 처리로, HW(아날로그 LPF/Schmitt) 또는 **디지털(샘플링+FF)** 으로 구현한다.

### 💡 아이디어
- 느린 샘플클록(예: 10Hz)으로 스위치를 **두 번 샘플** → `q1`, `q2`  
- **상승엣지 검출**: `single_pulse = q1 & ~q2`  
- 필요 시 시스템 클록 한 주기의 **싱크 펄스**로 다시 형성

### 💻 단일 펄스 디바운서 (게이트/구조적)
```verilog
// 50MHz -> 10Hz 분주기
module freq_div_10hz(input iCLK, input iRESETn, output oMYCLK);
  localparam VAL_CNT = 22'd2_500_000; // 50MHz / (2*2.5M) = 10Hz 토글
  reg [21:0] cnt; reg myclk;
  assign oMYCLK = myclk;
  always @(posedge iCLK or negedge iRESETn) begin
    if(!iRESETn) begin cnt<=0; myclk<=1'b0; end
    else if(cnt==VAL_CNT-1) begin cnt<=0; myclk<=~myclk; end
    else cnt<=cnt+1'b1;
  end
endmodule

// 비동기 클리어/프리셋을 가진 DFF (출력만 사용)
module d_ff(input iCLK, input iCLEARn, input iPRESETn, input iD, output reg oQ, output oQn);
  assign oQn = ~oQ;
  always @(posedge iCLK or negedge iCLEARn or negedge iPRESETn) begin
    if(!iCLEARn)      oQ <= 1'b0;
    else if(!iPRESETn)oQ <= 1'b1;
    else              oQ <= iD;
  end
endmodule

// 디바운스 + 단일펄스 출력
module debouncer(input iCLK, input iRESETn, input iSW, output oPULSE);
  wire slow; wire q1, qn2;
  freq_div_10hz UDIV(.iCLK(iCLK), .iRESETn(iRESETn), .oMYCLK(slow));
  d_ff U1(.iCLK(slow), .iCLEARn(iRESETn), .iPRESETn(1'b1), .iD(iSW), .oQ(q1));
  d_ff U2(.iCLK(slow), .iCLEARn(iRESETn), .iPRESETn(1'b1), .iD(q1),  .oQ(), .oQn(qn2));
  assign oPULSE = q1 & qn2; // q1 & ~q2
endmodule
```

#### 🧪 Testbench (3초 구동)
```verilog
`timescale 1ns/1ns
module tb_debouncer;
  localparam TCLK = 20; // 50MHz
  reg iCLK, iRESETn, iSW; wire oPULSE;
  debouncer DUT(.iCLK(iCLK), .iRESETn(iRESETn), .iSW(iSW), .oPULSE(oPULSE));

  initial begin iCLK=0; forever #(TCLK/2) iCLK=~iCLK; end
  initial begin
    iRESETn=1; #(TCLK/2); iRESETn=0; #200; iRESETn=1;
    iSW=0;
    repeat(5) begin
      #(TCLK*30_000_000) iSW=~iSW; // 0.6s 간격
    end
    #(TCLK*150_000_000); // 총 3s
    $stop;
  end
endmodule
```

### 💻 기준 클록 주기의 싱크 펄스 만들기
```verilog
module debouncer_clk(input iCLK, input iRESETn, input iSW, output oPULSE);
  wire slow; wire q1, qn2, q3, qn4;
  wire single_pulse;
  freq_div_10hz UDIV(.iCLK(iCLK), .iRESETn(iRESETn), .oMYCLK(slow));
  d_ff U1(.iCLK(slow), .iCLEARn(iRESETn), .iPRESETn(1'b1), .iD(iSW), .oQ(q1));
  d_ff U2(.iCLK(slow), .iCLEARn(iRESETn), .iPRESETn(1'b1), .iD(q1),  .oQ(), .oQn(qn2));
  assign single_pulse = q1 & qn2; // slow 도메인

  // 시스템 클록 도메인에서 1클록 펄스로 동기화
  d_ff U3(.iCLK(iCLK), .iCLEARn(iRESETn), .iPRESETn(1'b1), .iD(single_pulse), .oQ(q3));
  d_ff U4(.iCLK(iCLK), .iCLEARn(iRESETn), .iPRESETn(1'b1), .iD(q3),           .oQ(), .oQn(qn4));
  assign oPULSE = q3 & qn4; // 1 sys-clk pulse
endmodule
```

---

## 2. 텍스트 LCD

### ▶ 개요
- 일반적인 **HD44780 호환 16x2 LCD**: `RS, RW, E, DATA[7:0]`  
- 초기화(**Function Set, Display ON, Clear**) 후 **명령/데이터** 전송  
- 본 예제는 **쓰기 전용(RW=0)**, 8-bit 모드, 간단한 **FSM**으로 "HELLO" 출력

### 💻 LCD 이니셜라이저 & “HELLO” 출력 (50MHz 기준)
```verilog
module lcd_hello(
  input iCLK, input iRESETn,
  output RS, output RW, output E, output [7:0] DATA
);
  // RW 고정 0 (Write only)
  assign RW = 1'b0;

  // 간단 타이머(Enable 펄스와 명령 지연용)
  reg [19:0] tcnt; // ~20ms까지 확보(50MHz 기준)
  wire tick = (tcnt==20'd0);
  always @(posedge iCLK or negedge iRESETn) begin
    if(!iRESETn) tcnt <= 20'd999_999; // 초기 지연
    else tcnt <= (tcnt==0) ? 20'd50_000 : tcnt-1; // 1ms tick
  end

  // FSM
  typedef enum reg [3:0] {
    S_IDLE=0, S_FUNCSET, S_DISPON, S_CLEAR, S_ENTRY, S_SETADDR,
    S_H, S_E, S_L1, S_L2, S_O, S_DONE
  } st_t;
  st_t cs, ns;

  reg [7:0] data; reg rs; reg e;
  assign RS = rs; assign E = e; assign DATA = data;

  // Enable 펄스 (간단화: tick마다 토글)
  reg [1:0] ep;
  always @(posedge iCLK or negedge iRESETn) begin
    if(!iRESETn) ep<=0;
    else if(tick) ep <= ep + 1'b1;
  end
  always @* e = (ep==2'b01); // 짧은 펄스

  // 상태천이
  always @(posedge iCLK or negedge iRESETn) begin
    if(!iRESETn) cs<=S_IDLE; else if(tick) cs<=ns;
  end

  always @* begin
    ns = cs;
    rs = 1'b0; data = 8'h00;
    case(cs)
      S_IDLE:     ns = S_FUNCSET;
      S_FUNCSET:  begin data=8'b0011_1000; ns = S_DISPON; end // 8bit, 2line, 5x8
      S_DISPON:   begin data=8'b0000_1100; ns = S_CLEAR;  end // Display ON
      S_CLEAR:    begin data=8'b0000_0001; ns = S_ENTRY;  end // Clear
      S_ENTRY:    begin data=8'b0000_0110; ns = S_SETADDR;end // Entry mode
      S_SETADDR:  begin data=8'b1000_0000; ns = S_H;      end // DDRAM addr 0
      S_H:        begin rs=1; data="H"; ns = S_E; end
      S_E:        begin rs=1; data="E"; ns = S_L1; end
      S_L1:       begin rs=1; data="L"; ns = S_L2; end
      S_L2:       begin rs=1; data="L"; ns = S_O; end
      S_O:        begin rs=1; data="O"; ns = S_DONE; end
      S_DONE:     begin rs=1; data=" "; ns = S_DONE; end
    endcase
  end
endmodule
```

#### 🧪 간단 Testbench (파형 확인용)
```verilog
`timescale 1us/1ns
module tb_lcd_hello;
  reg iCLK, iRESETn; wire RS,RW,E; wire [7:0] DATA;
  lcd_hello DUT(.iCLK(iCLK), .iRESETn(iRESETn), .RS(RS), .RW(RW), .E(E), .DATA(DATA));
  initial iCLK=0; always #0.01 iCLK=~iCLK; // 50MHz 근사
  initial begin
    iRESETn=0; #100; iRESETn=1;
    #50_000; // 50 ms 관찰
    $stop;
  end
endmodule
```

> 실제 LCD 모듈에 따라 초기 지연/펄스 폭을 더 늘려야 할 수 있습니다. PMOD 인터페이스 연결 핀맵은 보드 매뉴얼을 참고하세요.

---

## 3. UART 통신

### ▶ 개요
- **UART TX/RX**: 비트 타이밍에 맞춰 **스타트(0) → 데이터 8bit → 스톱(1)** 전송/수신  
- 파라미터: `CLK_FREQ`, `BAUD`로 **분주값** 계산

### 💻 파라미터화된 UART TX/RX (8N1)
```verilog
module uart_baudgen #(parameter CLK_FREQ=50_000_000, BAUD=115200)
 (input iCLK, input iRESETn, output reg tick);
  localparam DIV = CLK_FREQ/BAUD;
  reg [$clog2(DIV)-1:0] cnt;
  always @(posedge iCLK or negedge iRESETn) begin
    if(!iRESETn) begin cnt<=0; tick<=1'b0; end
    else if(cnt==DIV-1) begin cnt<=0; tick<=1'b1; end
    else begin cnt<=cnt+1'b1; tick<=1'b0; end
  end
endmodule

module uart_tx #(parameter CLK_FREQ=50_000_000, BAUD=115200)
 (input iCLK, input iRESETn, input [7:0] iDATA, input iVALID, output reg oREADY,
  output reg oTX);
  reg [3:0] bitpos; reg [9:0] sh; wire tick;
  uart_baudgen #(.CLK_FREQ(CLK_FREQ),.BAUD(BAUD)) BG(.iCLK(iCLK),.iRESETn(iRESETn),.tick(tick));
  always @(posedge iCLK or negedge iRESETn) begin
    if(!iRESETn) begin oTX<=1'b1; oREADY<=1'b1; bitpos<=0; sh<=10'h3FF; end
    else if(oREADY && iVALID) begin
      sh <= {1'b1, iDATA, 1'b0}; // stop, data[7:0], start
      bitpos<=0; oREADY<=1'b0;
    end
    else if(!oREADY && tick) begin
      oTX <= sh[0]; sh <= {1'b1, sh[9:1]}; bitpos <= bitpos + 1'b1;
      if(bitpos==4'd9) oREADY<=1'b1;
    end
  end
endmodule

module uart_rx #(parameter CLK_FREQ=50_000_000, BAUD=115200)
 (input iCLK, input iRESETn, input iRX, output reg [7:0] oDATA, output reg oVALID);
  localparam DIV = CLK_FREQ/BAUD;
  reg [15:0] cnt; reg [3:0] bitpos; reg busy; reg rx_d;
  // 1x 샘플링(가운데 샘플) – 간단 버전
  always @(posedge iCLK or negedge iRESETn) begin
    if(!iRESETn) begin busy<=0; cnt<=0; bitpos<=0; oVALID<=0; end
    else begin
      oVALID<=0; rx_d<=iRX;
      if(!busy) begin
        if(rx_d==1'b0) begin busy<=1; cnt<=DIV+(DIV/2); bitpos<=0; end // start 검출 후 1.5비트 지연
      end else begin
        if(cnt==0) begin
          cnt<=DIV;
          if(bitpos<8) oDATA <= {rx_d, oDATA[7:1]}; // LSB first
          bitpos <= bitpos + 1'b1;
          if(bitpos==8) begin // stop
            oVALID<=1; busy<=0;
          end
        end else cnt<=cnt-1;
      end
    end
  end
endmodule
```

#### 🧪 Loopback Testbench
```verilog
`timescale 1ns/1ps
module tb_uart;
  localparam CLK=50_000_000, BAUD=115200;
  reg clk, rstn; reg [7:0] din; reg valid; wire ready; wire tx; wire [7:0] dout; wire vld;
  uart_tx #(.CLK_FREQ(CLK),.BAUD(BAUD)) TX(.iCLK(clk),.iRESETn(rstn),.iDATA(din),.iVALID(valid),.oREADY(ready),.oTX(tx));
  uart_rx #(.CLK_FREQ(CLK),.BAUD(BAUD)) RX(.iCLK(clk),.iRESETn(rstn),.iRX(tx),.oDATA(dout),.oVALID(vld));
  initial clk=0; always #10 clk=~clk; // 50MHz
  initial begin
    rstn=0; valid=0; din=8'h00; #200; rstn=1;
    repeat(5) begin
      @(posedge clk); din=$random; valid=1; @(posedge clk); valid=0;
      wait(vld==1);  // 수신 완료
    end
    $stop;
  end
endmodule
```

> 실사용 시는 **오버샘플링(16x)**, 프레이밍/패리티 에러 검출 등을 추가하세요.

---

## 4. 디지털 필터

### ▶ 개요
- **FIR(유한 임펄스 응답)**: 고정 계수와 지연선으로 구성, 항상 안정적  
- **IIR(무한 임펄스 응답)**: 피드백 포함, 적은 탭으로 날카로운 응답 가능

### 💻 FIR: 4-탭 이동평균 필터 (8-bit → 8-bit)
```verilog
module fir_movavg4(input iCLK, input iRESETn, input [7:0] iX, output [7:0] oY);
  reg [7:0] d1,d2,d3; reg [9:0] sum; // 최대 4*255=1020 -> 10bit
  always @(posedge iCLK or negedge iRESETn) begin
    if(!iRESETn) begin d1<=0; d2<=0; d3<=0; sum<=0; end
    else begin
      sum <= iX + d1 + d2 + d3;
      d3 <= d2; d2 <= d1; d1 <= iX;
    end
  end
  assign oY = sum[9:2]; // /4
endmodule
```

### 💻 IIR: 1차 저역통과(고정소수점 – α=1/8)
```verilog
module iir_lp1 #(parameter ALPHA_SHIFT=3) // y[n]=y[n-1]+(x[n]-y[n-1])*(1/2^s)
 (input iCLK, input iRESETn, input [7:0] iX, output reg [7:0] oY);
  reg [10:0] acc;
  always @(posedge iCLK or negedge iRESETn) begin
    if(!iRESETn) begin oY<=0; acc<=0; end
    else begin
      acc <= {{3{1'b0}}, oY} + ({{3{1'b0}}, iX} - {{3{1'b0}}, oY}) >> ALPHA_SHIFT;
      oY  <= acc[7:0];
    end
  end
endmodule
```

#### 🧪 간단 Testbench (임펄스/스텝 응답 관찰)
```verilog
`timescale 1ns/1ps
module tb_filters;
  reg clk, rstn; reg [7:0] x; wire [7:0] yfir, yiir;
  fir_movavg4 FIR(.iCLK(clk), .iRESETn(rstn), .iX(x), .oY(yfir));
  iir_lp1     IIR(.iCLK(clk), .iRESETn(rstn), .iX(x), .oY(yiir));
  initial clk=0; always #10 clk=~clk;
  integer i;
  initial begin
    rstn=0; x=0; #100; rstn=1;
    // 임펄스 입력
    x=8'd255; #20; x=0; #200;
    // 스텝 입력
    x=8'd128; for(i=0;i<50;i=i+1) #20;
    $stop;
  end
endmodule
```

---

### ✅ 마무리 팁
- 외부 디바이스(LCD/UART)는 **데이터시트의 시간요건**(setup/hold, pulse width)을 반드시 반영하세요.  
- 클록 도메인 간 신호 이동 시엔 **동기화 FF** 또는 **CDC 회로**를 사용하세요.  
- 시뮬레이션에서 동작 확인 후, **핀 제약(XDC)** 과 **타이밍 분석**을 완료하세요.
