# 🚀 Vivado & Vitis로 시작하는 베어메탈 소프트웨어 프로젝트

<img width="866" height="441" alt="012" src="https://github.com/user-attachments/assets/ce5b2179-626b-42ce-b8bd-4f7dcea74965" />
<br>

---

| 구분             | IP 이름                | 아키텍처              | Vivado 버전 | 사용 가능 | 비고         |
| -------------- | -------------------- | ----------------- | --------- | ----- | ---------- |
| 기존 Soft CPU    | MicroBlaze           | Xilinx ISA        | ≤ 2023.x  | ✅     | 구형         |
| MCU 형 Soft CPU | MicroBlaze MCS       | Xilinx ISA        | ≤ 2023.x  | ✅     | 구형         |
| 차세대 Soft CPU   | **MicroBlaze V**     | **RISC-V RV32IM** | ≥ 2024.1  | ✅     | 표준 RISC-V  |
| 경량형 RISC-V MCU | **MicroBlaze MCS V** | **RISC-V RV32IM** | ≥ 2024.1  | ✅     | 내장형 MCU    |
| 교육용 8-bit      | KCPSM6 (PicoBlaze)   | 전용 8-bit          | 모든 버전 수동  | ✅     | VHDL 직접 추가 |


## 개요 (Overview)
이 가이드는 **Vivado**와 **Vitis**에서 프로젝트를 설정하는 과정을 단계별로 설명합니다. 버튼과 LED에 연결된 여러 **AXI GPIO** 주변장치를 포함하는 **프로세서 기반 간단한 하드웨어 설계**를 만들고, 이를 **Vitis IDE**로 내보낸 뒤 **베어메탈 소프트웨어 프로젝트**를 생성하여 버튼을 폴링(poll)하고 LED를 제어하는 예제를 실행합니다.  
(하드웨어만 사용하는 경우에는 *Vivado for Hardware-Only Designs* 참고)

---

## 요구 사항 (Requirements)

### 하드웨어
- Digilent FPGA 개발 보드 1대
- 보드에 필요한 **USB 프로그래밍 케이블**, **USB UART 케이블**, **전원 공급장치**
> **주의:** **Genesys ZU**는 Zynq Ultrascale+ MPSoC를 사용하므로 부트로더 추가 설정이 필요합니다. 본 가이드의 적용 대상이 아니며, 해당 보드 리소스 센터의 시작 가이드를 확인하세요.

### 소프트웨어
- **Vivado** 및 **Vitis** 설치  
  설치 방법: *Installing Vivado, Vitis, and Digilent Board Files*
- **보드 파일(Board Files)**  
  이 가이드는 GitHub의 Digilent `vivado-library` 저장소에 있는 보드 파일을 기준으로 합니다(위 설치 가이드 참고).

> 본 가이드의 스크린샷은 사용 중인 버전과 다를 수 있으나, **Vivado/Vitis 2022.1**에서 워크플로는 검증되었습니다.  
> **Vitis 2023.2**는 UI 변경으로 프로젝트 생성 절차가 크게 달라졌습니다(adiuvoengineering 블로그의 Adam Taylor 글 참고). 또한, 본 튜토리얼의 예제 코드는 **2023.2 이상 버전에서 동작하지 않을 수 있습니다**.  
> Vivado에 **Xilinx SDK(2019.1 이하)** 가 포함된 버전을 사용한다면, *Getting Started with Vivado IP Integrator and Xilinx SDK*를 참고하세요.

> **참고:** 사용자 Viktor Nikolov이 Digilent 포럼에 MicroBlaze + DDR용 대체 클록 구조 튜토리얼을 게시했습니다(Arty A7, Arty S7, Nexys A7, Nexys Video, USB104 A7 해당). 기존 플로우에서 발생할 수 있는 오류를 회피하도록 구성되어 있으며, 입문자에게 권장됩니다.  
> 포럼 글: https://forum.digilent.com/topic/27389-arty-a7-microblaze-ddr3-tutorial/

---

## 가이드 (Guide)

### 1. Vivado 실행 (Launch Vivado)

#### Windows
- 설치 시 생성된 시작 메뉴/바탕화면 아이콘으로 Vivado 실행

#### Linux
```bash
source <install_path>/Vivado/<version>/settings64.sh
vivado
```

---

### 2. Vivado 프로젝트 생성 (Create a Vivado Project)
Vivado 시작 화면:
- **Create Project**: 새 프로젝트 마법사 시작(본 가이드 사용)
- **Open Project**: 기존 XPR 프로젝트 열기
- **Open Hardware Manager**: 프로젝트 없이 비트스트림만 보드에 다운로드

1) **Create Project** 클릭 → **Next**  
2) 프로젝트 이름/위치 지정  
   - **공백 사용 금지**(문제 발생). 언더스코어/대시/CamelCase 권장  
   - `Create project subdirectory` 체크 권장 → **Next**
3) **Project Type**: **RTL Project** 선택, **Do not specify sources at this time** 체크 → **Next**
4) 타깃 **Board** 또는 **Part** 선택  
   - **Board** 선택 권장(보드 파일을 통한 추가 구성 정보 제공)  
   - 보드가 보이지 않으면 **보드 파일 설치** 필요  
   - Vivado 2022.2는 보드 목록 **Refresh/Install** 추가 단계 있음 → **Next**
5) 요약 확인 → **Finish**

---

### 3. 블록 디자인 생성 (Create a Block Design)
- Flow Navigator → **IP Integrator** → **Create Block Design**
- 이름 지정(예: `design_1`) — **공백 금지** → **OK**

---

### 4. 프로세서 추가 (Add a Processor)

> **MicroBlaze**: Zynq 디바이스가 없는 보드에서 사용  
> **Zynq7 Processing System(PS)**: Zynq 보드에서 사용

#### 4-1) MicroBlaze 추가 (DDR 없음 보드)

1) **Board** 탭에서 **System Clock** 우클릭 → **Connect Board Component**  
   - **Clocking Wizard**의 `CLK_IN1`에 연결(클록 생성용)
2) **Run Connection Automation** → Clocking Wizard의 **reset** 연결  
   - 보드 리셋 극성에 따라 **Utility Vector Logic**가 자동 삽입될 수 있음
3) Clocking Wizard 더블클릭 → **Output Clocks** 탭에서 필요한 출력 클록(주파수/이름) 설정 → **OK**
4) **Add IP** → **MicroBlaze** 추가
5) 상단 **Run Block Automation**  
   - 주요 옵션
     - *Local Memory*: DDR이 없으면 더 큰 BRAM 필요(작은 앱은 **32KB**도 가능)
     - *Cache Configuration*: DDR 사용 시 **Enable**, 그 외 **Disable**
     - *Peripheral AXI Port*: 주변장치 연결 위해 **Enable**
     - *Interrupt Controller*: 인터럽트 필요한 경우 **체크**
     - *Clock Connection*: DDR 없는 설계는 **Clocking Wizard `clk_out1`** 사용
   - 설정 확인 후 **OK**
6) **USB UART** 인터페이스 연결  
   - Board 탭 → UART 우클릭 → **Connect Board Component** → **AXI Uartlite** 선택
7) **Run Connection Automation** → 남은 AXI 인터페이스 자동 연결

#### 4-2) MicroBlaze 추가 (DDR 있는 보드)

> DDR을 먼저 구성하여 시스템 클록 소스로 활용하는 것이 좋습니다.

1) Board 탭에서 **DDR** 우클릭 → **Auto Connect**  
   - MIG + 외부 DDR 인터페이스 추가, `clk_ref_i`/`ui_addn_clk_0` 생성
2) `clk_ref_i` **삭제**
3) `ui_addn_clk_0`의 **Frequency ~200 MHz** 확인 → `ui_addn_clk_0`를 `clk_ref_i`에 **수동 연결**
4) `sys_clk_i`는 보드 파일로 제약되지 않으므로 **XDC 제약 추가 필요**
   - *digilent-xdc-master.zip* 다운로드/압축 해제
   - **Add Sources** → **Add or create constraints** → **constrs_1**에 **보드 XDC** 추가(복사 옵션 체크)
   - XDC에서 **100 MHz 입력 클록** 제약의 `create_clock -period 10.000` 항목을 `sys_clk_i`로 수정/저장
5) **Run Connection Automation** → `sys_rst`를 보드 리셋에 연결
6) MIG의 기타 포트 처리
   - `device_temp_i`가 있으면 **Constant(12'b0)** 으로 접지
7) 추가 클록 필요 시 **Clocking Wizard** 추가  
   - 입력: `MIG ui_clk`, 리셋: `ui_clk_sync_rst`  
   - **Output Clocks** 탭에서 필요 주파수 생성
8) **Add IP** → **MicroBlaze** 추가 → **Run Block Automation**
   - *Clock Connection*: `MIG ui_clk` 또는 위에서 만든 클록 사용(**`MIG sys_clk_i` 입력을 선택하지 않도록 주의**)
9) **Run Connection Automation** → **MIG S_AXI**를 **MicroBlaze (Cached)** 에 연결
10) **USB UART** 연결(AXI Uartlite) → **Run Connection Automation**으로 나머지 자동 연결

#### 4-3) Zynq7 Processing System 추가

1) **Add IP** → **ZYNQ7 Processing System**  
2) 상단 **Run Block Automation** → **Apply Board Preset** 유지 → **OK**
3) 설정 변경 필요 시 더블클릭  
   - **Clock Configuration → PL Fabric Clocks(FCLKs)**: 추가 클록 활성화/주파수 설정 가능  
   - **Interrupts → Fabric Interrupts → IRQ_F2P**: 인터럽트 사용 시 활성화(여러 소스면 **Concat IP**로 합치기)

---

### 5. AXI GPIO 주변장치 추가 (Add GPIO Peripherals)

1) **Board 탭** → **GPIO/LED** 인터페이스 우클릭 → **Connect Board Interface**  
   - 새 **AXI GPIO**의 `GPIO` 인터페이스 선택  
   - 일부 보드는 리셋 버튼을 리셋 소스로 쓰므로, 해당 모드가 아닌 구성 선택
2) Diagram 좌측 **Block Properties**에서 이름 변경(예: `AXI_GPIO_LED`)
3) **두 번째 AXI GPIO** 수동 추가(버튼용) → 이름 `AXI_GPIO_BUTTONS`  
   - `GPIO` 인터페이스 우클릭 → **Make External** (보드 파일 의존 X)
4) **보드 XDC** 추가(위와 동일 절차) → **버튼 핀 제약** 주석 해제  
   - 외부 포트 이름을 **`btn`** 로 변경  
   - XDC 내 `get_ports` 이름을 `btn_tri_io[#]`로 수정(0부터 인덱싱)
5) `AXI_GPIO_BUTTONS` 더블클릭 → **GPIO Width**를 버튼 수에 맞게 설정 → **OK**
6) **Run Connection Automation** → 두 AXI GPIO의 `S_AXI`를 **프로세서**에 연결

---

### 6. 주소 맵 편집 (Edit the Address Map)
- 드물게 AXI 주소 자동 할당 실패 시 **Address Editor**에서 수동 지정  
- **범위 정렬/중복 금지**, **0 주소 할당 지양**  
- 수정 후 **Validate Design** 재실행

---

### 7. 블록 디자인 검증 (Validate a Block Design)
- Diagram 툴바의 **Validate Design(F6)** 클릭  
- 경고 대부분은 무시 가능(일부 Zynq 보드의 DDR DQS 경고 포함 — 보드 매뉴얼 Errata 참고)

---

### 8. HDL Wrapper 생성 (Create an HDL Wrapper)
- **Sources** → `.bd` 파일 우클릭 → **Create HDL Wrapper**  
- **Let Vivado manage wrapper and auto-update** 권장

```
## This file is a general .xdc for the Basys3 rev B board
## To use it in a project:
## - uncomment the lines corresponding to used pins
## - rename the used ports (in each line, after get_ports) according to the top level signal names in the project

## Clock signal
set_property -dict { PACKAGE_PIN W5   IOSTANDARD LVCMOS33 } [get_ports sys_clock]
create_clock -add -name sys_clk_pin -period 10.00 -waveform {0 5} [get_ports sys_clock]


## Switches
set_property -dict { PACKAGE_PIN V17   IOSTANDARD LVCMOS33 } [get_ports {dip_switches[0]}]
set_property -dict { PACKAGE_PIN V16   IOSTANDARD LVCMOS33 } [get_ports {dip_switches[1]}]
set_property -dict { PACKAGE_PIN W16   IOSTANDARD LVCMOS33 } [get_ports {dip_switches[2]}]
set_property -dict { PACKAGE_PIN W17   IOSTANDARD LVCMOS33 } [get_ports {dip_switches[3]}]
set_property -dict { PACKAGE_PIN W15   IOSTANDARD LVCMOS33 } [get_ports {dip_switches[4]}]
set_property -dict { PACKAGE_PIN V15   IOSTANDARD LVCMOS33 } [get_ports {dip_switches[5]}]
set_property -dict { PACKAGE_PIN W14   IOSTANDARD LVCMOS33 } [get_ports {dip_switches[6]}]
set_property -dict { PACKAGE_PIN W13   IOSTANDARD LVCMOS33 } [get_ports {dip_switches[7]}]
set_property -dict { PACKAGE_PIN V2    IOSTANDARD LVCMOS33 } [get_ports {dip_switches[8]}]
set_property -dict { PACKAGE_PIN T3    IOSTANDARD LVCMOS33 } [get_ports {dip_switches[9]}]
set_property -dict { PACKAGE_PIN T2    IOSTANDARD LVCMOS33 } [get_ports {dip_switches[10]}]
set_property -dict { PACKAGE_PIN R3    IOSTANDARD LVCMOS33 } [get_ports {dip_switches[11]}]
set_property -dict { PACKAGE_PIN W2    IOSTANDARD LVCMOS33 } [get_ports {dip_switches[12]}]
set_property -dict { PACKAGE_PIN U1    IOSTANDARD LVCMOS33 } [get_ports {dip_switches[13]}]
set_property -dict { PACKAGE_PIN T1    IOSTANDARD LVCMOS33 } [get_ports {dip_switches[14]}]
set_property -dict { PACKAGE_PIN R2    IOSTANDARD LVCMOS33 } [get_ports {dip_switches[15]}]


## LEDs
set_property -dict { PACKAGE_PIN U16   IOSTANDARD LVCMOS33 } [get_ports {led[0]}]
set_property -dict { PACKAGE_PIN E19   IOSTANDARD LVCMOS33 } [get_ports {led[1]}]
set_property -dict { PACKAGE_PIN U19   IOSTANDARD LVCMOS33 } [get_ports {led[2]}]
set_property -dict { PACKAGE_PIN V19   IOSTANDARD LVCMOS33 } [get_ports {led[3]}]
set_property -dict { PACKAGE_PIN W18   IOSTANDARD LVCMOS33 } [get_ports {led[4]}]
set_property -dict { PACKAGE_PIN U15   IOSTANDARD LVCMOS33 } [get_ports {led[5]}]
set_property -dict { PACKAGE_PIN U14   IOSTANDARD LVCMOS33 } [get_ports {led[6]}]
set_property -dict { PACKAGE_PIN V14   IOSTANDARD LVCMOS33 } [get_ports {led[7]}]
set_property -dict { PACKAGE_PIN V13   IOSTANDARD LVCMOS33 } [get_ports {led[8]}]
set_property -dict { PACKAGE_PIN V3    IOSTANDARD LVCMOS33 } [get_ports {led[9]}]
set_property -dict { PACKAGE_PIN W3    IOSTANDARD LVCMOS33 } [get_ports {led[10]}]
set_property -dict { PACKAGE_PIN U3    IOSTANDARD LVCMOS33 } [get_ports {led[11]}]
set_property -dict { PACKAGE_PIN P3    IOSTANDARD LVCMOS33 } [get_ports {led[12]}]
set_property -dict { PACKAGE_PIN N3    IOSTANDARD LVCMOS33 } [get_ports {led[13]}]
set_property -dict { PACKAGE_PIN P1    IOSTANDARD LVCMOS33 } [get_ports {led[14]}]
set_property -dict { PACKAGE_PIN L1    IOSTANDARD LVCMOS33 } [get_ports {led[15]}]


##7 Segment Display
#set_property -dict { PACKAGE_PIN W7   IOSTANDARD LVCMOS33 } [get_ports {seg[0]}]
#set_property -dict { PACKAGE_PIN W6   IOSTANDARD LVCMOS33 } [get_ports {seg[1]}]
#set_property -dict { PACKAGE_PIN U8   IOSTANDARD LVCMOS33 } [get_ports {seg[2]}]
#set_property -dict { PACKAGE_PIN V8   IOSTANDARD LVCMOS33 } [get_ports {seg[3]}]
#set_property -dict { PACKAGE_PIN U5   IOSTANDARD LVCMOS33 } [get_ports {seg[4]}]
#set_property -dict { PACKAGE_PIN V5   IOSTANDARD LVCMOS33 } [get_ports {seg[5]}]
#set_property -dict { PACKAGE_PIN U7   IOSTANDARD LVCMOS33 } [get_ports {seg[6]}]

#set_property -dict { PACKAGE_PIN V7   IOSTANDARD LVCMOS33 } [get_ports dp]

#set_property -dict { PACKAGE_PIN U2   IOSTANDARD LVCMOS33 } [get_ports {an[0]}]
#set_property -dict { PACKAGE_PIN U4   IOSTANDARD LVCMOS33 } [get_ports {an[1]}]
#set_property -dict { PACKAGE_PIN V4   IOSTANDARD LVCMOS33 } [get_ports {an[2]}]
#set_property -dict { PACKAGE_PIN W4   IOSTANDARD LVCMOS33 } [get_ports {an[3]}]


##Buttons
#set_property -dict { PACKAGE_PIN U18   IOSTANDARD LVCMOS33 } [get_ports reset]
#set_property -dict { PACKAGE_PIN T18   IOSTANDARD LVCMOS33 } [get_ports btnU]
#set_property -dict { PACKAGE_PIN W19   IOSTANDARD LVCMOS33 } [get_ports btnL]
#set_property -dict { PACKAGE_PIN T17   IOSTANDARD LVCMOS33 } [get_ports btnR]
#set_property -dict { PACKAGE_PIN U17   IOSTANDARD LVCMOS33 } [get_ports btnD]


##Pmod Header JA
#set_property -dict { PACKAGE_PIN J1   IOSTANDARD LVCMOS33 } [get_ports {JA[0]}];#Sch name = JA1
#set_property -dict { PACKAGE_PIN L2   IOSTANDARD LVCMOS33 } [get_ports {JA[1]}];#Sch name = JA2
#set_property -dict { PACKAGE_PIN J2   IOSTANDARD LVCMOS33 } [get_ports {JA[2]}];#Sch name = JA3
#set_property -dict { PACKAGE_PIN G2   IOSTANDARD LVCMOS33 } [get_ports {JA[3]}];#Sch name = JA4
#set_property -dict { PACKAGE_PIN H1   IOSTANDARD LVCMOS33 } [get_ports {JA[4]}];#Sch name = JA7
#set_property -dict { PACKAGE_PIN K2   IOSTANDARD LVCMOS33 } [get_ports {JA[5]}];#Sch name = JA8
#set_property -dict { PACKAGE_PIN H2   IOSTANDARD LVCMOS33 } [get_ports {JA[6]}];#Sch name = JA9
#set_property -dict { PACKAGE_PIN G3   IOSTANDARD LVCMOS33 } [get_ports {JA[7]}];#Sch name = JA10

##Pmod Header JB
#set_property -dict { PACKAGE_PIN A14   IOSTANDARD LVCMOS33 } [get_ports {JB[0]}];#Sch name = JB1
#set_property -dict { PACKAGE_PIN A16   IOSTANDARD LVCMOS33 } [get_ports {JB[1]}];#Sch name = JB2
#set_property -dict { PACKAGE_PIN B15   IOSTANDARD LVCMOS33 } [get_ports {JB[2]}];#Sch name = JB3
#set_property -dict { PACKAGE_PIN B16   IOSTANDARD LVCMOS33 } [get_ports {JB[3]}];#Sch name = JB4
#set_property -dict { PACKAGE_PIN A15   IOSTANDARD LVCMOS33 } [get_ports {JB[4]}];#Sch name = JB7
#set_property -dict { PACKAGE_PIN A17   IOSTANDARD LVCMOS33 } [get_ports {JB[5]}];#Sch name = JB8
#set_property -dict { PACKAGE_PIN C15   IOSTANDARD LVCMOS33 } [get_ports {JB[6]}];#Sch name = JB9
#set_property -dict { PACKAGE_PIN C16   IOSTANDARD LVCMOS33 } [get_ports {JB[7]}];#Sch name = JB10

##Pmod Header JC
#set_property -dict { PACKAGE_PIN K17   IOSTANDARD LVCMOS33 } [get_ports {JC[0]}];#Sch name = JC1
#set_property -dict { PACKAGE_PIN M18   IOSTANDARD LVCMOS33 } [get_ports {JC[1]}];#Sch name = JC2
#set_property -dict { PACKAGE_PIN N17   IOSTANDARD LVCMOS33 } [get_ports {JC[2]}];#Sch name = JC3
#set_property -dict { PACKAGE_PIN P18   IOSTANDARD LVCMOS33 } [get_ports {JC[3]}];#Sch name = JC4
#set_property -dict { PACKAGE_PIN L17   IOSTANDARD LVCMOS33 } [get_ports {JC[4]}];#Sch name = JC7
#set_property -dict { PACKAGE_PIN M19   IOSTANDARD LVCMOS33 } [get_ports {JC[5]}];#Sch name = JC8
#set_property -dict { PACKAGE_PIN P17   IOSTANDARD LVCMOS33 } [get_ports {JC[6]}];#Sch name = JC9
#set_property -dict { PACKAGE_PIN R18   IOSTANDARD LVCMOS33 } [get_ports {JC[7]}];#Sch name = JC10

##Pmod Header JXADC
#set_property -dict { PACKAGE_PIN J3   IOSTANDARD LVCMOS33 } [get_ports {JXADC[0]}];#Sch name = XA1_P
#set_property -dict { PACKAGE_PIN L3   IOSTANDARD LVCMOS33 } [get_ports {JXADC[1]}];#Sch name = XA2_P
#set_property -dict { PACKAGE_PIN M2   IOSTANDARD LVCMOS33 } [get_ports {JXADC[2]}];#Sch name = XA3_P
#set_property -dict { PACKAGE_PIN N2   IOSTANDARD LVCMOS33 } [get_ports {JXADC[3]}];#Sch name = XA4_P
#set_property -dict { PACKAGE_PIN K3   IOSTANDARD LVCMOS33 } [get_ports {JXADC[4]}];#Sch name = XA1_N
#set_property -dict { PACKAGE_PIN M3   IOSTANDARD LVCMOS33 } [get_ports {JXADC[5]}];#Sch name = XA2_N
#set_property -dict { PACKAGE_PIN M1   IOSTANDARD LVCMOS33 } [get_ports {JXADC[6]}];#Sch name = XA3_N
#set_property -dict { PACKAGE_PIN N1   IOSTANDARD LVCMOS33 } [get_ports {JXADC[7]}];#Sch name = XA4_N


##VGA Connector
#set_property -dict { PACKAGE_PIN G19   IOSTANDARD LVCMOS33 } [get_ports {vgaRed[0]}]
#set_property -dict { PACKAGE_PIN H19   IOSTANDARD LVCMOS33 } [get_ports {vgaRed[1]}]
#set_property -dict { PACKAGE_PIN J19   IOSTANDARD LVCMOS33 } [get_ports {vgaRed[2]}]
#set_property -dict { PACKAGE_PIN N19   IOSTANDARD LVCMOS33 } [get_ports {vgaRed[3]}]
#set_property -dict { PACKAGE_PIN N18   IOSTANDARD LVCMOS33 } [get_ports {vgaBlue[0]}]
#set_property -dict { PACKAGE_PIN L18   IOSTANDARD LVCMOS33 } [get_ports {vgaBlue[1]}]
#set_property -dict { PACKAGE_PIN K18   IOSTANDARD LVCMOS33 } [get_ports {vgaBlue[2]}]
#set_property -dict { PACKAGE_PIN J18   IOSTANDARD LVCMOS33 } [get_ports {vgaBlue[3]}]
#set_property -dict { PACKAGE_PIN J17   IOSTANDARD LVCMOS33 } [get_ports {vgaGreen[0]}]
#set_property -dict { PACKAGE_PIN H17   IOSTANDARD LVCMOS33 } [get_ports {vgaGreen[1]}]
#set_property -dict { PACKAGE_PIN G17   IOSTANDARD LVCMOS33 } [get_ports {vgaGreen[2]}]
#set_property -dict { PACKAGE_PIN D17   IOSTANDARD LVCMOS33 } [get_ports {vgaGreen[3]}]
#set_property -dict { PACKAGE_PIN P19   IOSTANDARD LVCMOS33 } [get_ports Hsync]
#set_property -dict { PACKAGE_PIN R19   IOSTANDARD LVCMOS33 } [get_ports Vsync]


##USB-RS232 Interface
set_property -dict { PACKAGE_PIN B18   IOSTANDARD LVCMOS33 } [get_ports uart_rx]
set_property -dict { PACKAGE_PIN A18   IOSTANDARD LVCMOS33 } [get_ports uart_tx]


##USB HID (PS/2)
#set_property -dict { PACKAGE_PIN C17   IOSTANDARD LVCMOS33   PULLUP true } [get_ports PS2Clk]
#set_property -dict { PACKAGE_PIN B17   IOSTANDARD LVCMOS33   PULLUP true } [get_ports PS2Data]


##Quad SPI Flash
##Note that CCLK_0 cannot be placed in 7 series devices. You can access it using the
##STARTUPE2 primitive.
#set_property -dict { PACKAGE_PIN D18   IOSTANDARD LVCMOS33 } [get_ports {QspiDB[0]}]
#set_property -dict { PACKAGE_PIN D19   IOSTANDARD LVCMOS33 } [get_ports {QspiDB[1]}]
#set_property -dict { PACKAGE_PIN G18   IOSTANDARD LVCMOS33 } [get_ports {QspiDB[2]}]
#set_property -dict { PACKAGE_PIN F18   IOSTANDARD LVCMOS33 } [get_ports {QspiDB[3]}]
#set_property -dict { PACKAGE_PIN K19   IOSTANDARD LVCMOS33 } [get_ports QspiCSn]


## Configuration options, can be used for all designs
set_property CONFIG_VOLTAGE 3.3 [current_design]
set_property CFGBVS VCCO [current_design]

## SPI configuration mode options for QSPI boot, can be used for all designs
set_property BITSTREAM.GENERAL.COMPRESS TRUE [current_design]
set_property BITSTREAM.CONFIG.CONFIGRATE 33 [current_design]
set_property CONFIG_MODE SPIx4 [current_design]
```

---

### 9. 프로젝트 빌드 (Build a Vivado Project)
- Flow Navigator → **Program and Debug → Generate Bitstream**  
- **Number of jobs**는 가능한 큰 값 권장  
- 특정 경고(패키징 보드 값, Zynq CK-to-DQS 음수 지연 등)는 무시 가능  
- 완료 후 **Open Implemented Design / View Reports / Open Hardware Manager / Generate MCS** 등 선택 또는 **Cancel**

---

### 10. 고정(Post-Synth) 하드웨어 플랫폼 내보내기 (Export a Fixed Post-Synthesis Hardware Platform)
- **File → Export → Export Hardware**
  - 플랫폼 유형: **Fixed** 선택(2022.1에는 화면 생략 가능)
  - **Include bitstream** 선택(비트 포함 시 Vitis에서 자동 참조)
  - **XSA 이름/경로** 지정(공백 금지, 언더스코어/카멜케이스 권장)
  - 요약 확인 후 **Finish**

---

### 11. Vitis 실행 (Launch Vitis)
- OS별 실행 또는 Vivado에서 **Tools → Launch Vitis**
- **Workspace** 선택(없으면 생성) → **Launch**

---

### 12. 새 Application 프로젝트 생성 (Create a New Application Project)
1) Vitis 시작 화면 → **Create Application Project**
2) 환영 화면 → **Next**
3) **Create a new platform…** 탭 → 앞서 내보낸 **XSA**를 **Open**  
   - Hardware Specification 목록에서 선택  
   - 플랫폼 이름 지정(기본값 사용 가능)  
   - **Generate boot components** 체크 권장 → **Next**
4) 시스템/애플리케이션 이름 및 타깃 코어 설정(기본값 사용) → **Next**
5) 도메인 설정(기본값) → **Next**
6) 템플릿: **Empty Application**(C 또는 C++) 선택 → **Finish**

---

### 13. AXI GPIO를 제어하는 C 소스 생성 (Create a Main C Source)
1) Explorer의 **프로젝트 `src` 폴더** 우클릭 → **New → File** → 파일명 `main.c`
2) **Vitis 2023.2**에서는 `xparameters.h`의 디바이스 ID 대신 **BASEADDR 기반 초기화**를 사용해야 할 수 있음(예: `XGpio_LookupConfig(XPAR_AXI_GPIO_BUTTONS_BASEADDR)`).
3) 아래 코드를 `main.c`에 복사.  
   - `BTN_MASK`와 `LED_MASK`를 **보드의 버튼/LED 개수**에 맞게 1의 비트 수로 설정

**헤더 설명**
- `xparameters.h`: Vivado 플랫폼 내보내기 시 생성되는 하드웨어 정보(주소/파라미터 등)
- `xil_printf.h`: `xil_printf`(표준 출력) — `stdio`보다 메모리 사용량 적음
- `xgpio.h`: AXI GPIO 드라이버 API
- `xil_types.h`: `u32` 등 Xilinx 타입 정의

**동작 요약**
- 시작 시 `"Entered function main"` 메시지 출력
- GPIO 초기화 후 루프에서 버튼 상태 읽기 → 버튼 누름 시 LED ON, 아니면 OFF

```c
#include "xgpio.h"
#include "xparameters.h"
#include "xil_printf.h"
#include "sleep.h"

// ----- 현재 디자인: AXI GPIO 하나에 채널1=LED, 채널2=BUTTON -----
#define GPIO_DEVICE_ID   XPAR_GPIO_0_DEVICE_ID
#define LED_CHANNEL      1   // 출력 채널
#define BTN_CHANNEL      2   // 입력 채널
#define BTN_MASK         0x0F
#define LED_MASK         0x0F

int main(void)
{
    int status;
    XGpio gpio;
    XGpio_Config *cfg_ptr;

    xil_printf("AXI GPIO (1 IP / 2 channels) test start\r\n");

    // 단일 AXI GPIO IP로 초기화
    cfg_ptr = XGpio_LookupConfig(GPIO_DEVICE_ID);
    if (cfg_ptr == NULL) {
        xil_printf("LookupConfig failed\r\n");
        return -1;
    }

    status = XGpio_CfgInitialize(&gpio, cfg_ptr, cfg_ptr->BaseAddress);
    if (status != XST_SUCCESS) {
        xil_printf("CfgInitialize failed\r\n");
        return -1;
    }

    // 방향 설정: LED 채널은 출력(0), BTN 채널은 입력(1)
    XGpio_SetDataDirection(&gpio, LED_CHANNEL, 0x00); // 8비트 모두 출력
    XGpio_SetDataDirection(&gpio, BTN_CHANNEL, 0xFF); // 8비트 모두 입력

    // 초기 LED 끄기
    XGpio_DiscreteWrite(&gpio, LED_CHANNEL, 0x00);

    while (1) {
        u32 btn = XGpio_DiscreteRead(&gpio, BTN_CHANNEL) & BTN_MASK;
        // 버튼 하위 4비트를 LED 하위 4비트에 미러링
        XGpio_DiscreteWrite(&gpio, LED_CHANNEL, btn & LED_MASK);
        usleep(1000); // 1 ms
    }

    return 0;
}
```

---

### 14. Vitis 애플리케이션 빌드 (Build a Vitis Application)
- **Assistant** 창에서 **[System] 프로젝트** 선택 → **Build** 버튼 또는 **Ctrl+B**
- **Platforms / Systems / Applications** 빌드 타깃 차이 유의  
- 완료 후 **Console**에 “Build Finished” 표시

---

1) Linker 스크립트에서 Heap/Stack 축소

Vitis에서 lscript.ld 열기 → GUI 또는 텍스트 편집:

Heap Size = 0 (malloc/new 안 쓰면 0으로)

Stack Size = 0x0200 (512B) 또는 더 작게 (필요 시 256B)

텍스트라면 맨 아래 매크로 값만 바꿔도 됩니다:

/* lscript.ld 하단 근처 */
_heap_size  = 0x0000;  /* 동적할당 안 쓰면 0 */
_stack_size = 0x0200;  /* 512 bytes (안되면 0x0100 = 256B) */


저장 → Project Clean → Build.

여전히 초과하면 stack을 256B까지 줄여보세요. (이 예제는 ISR/재귀 없음)

2) 코드 사이즈 더 줄이기 (옵션)

컴파일 옵션을 -Os 로 변경 (Size 최적화)
Project → C/C++ Build Settings → Compiler → Optimization → -Os

이미 xil_printf를 쓰고 있으니 heap=0으로 충분합니다.

큰 전역/지역 배열, printf 포맷 문자열 남용이 없는지 확인

3) 그래도 부족하면: BRAM 용량 늘리기 (Vivado)

BD에서 MicroBlaze Run Block Automation 다시 열기 → Local Memory Size를 32KB→64KB로 증설

Bitstream 재생성 → Export Hardware (Include bitstream)

Vitis에서 Platform 재생성(Regenerate BSP) → 앱 Clean/Build

Basys3는 DDR이 없으니, 로컬 메모리를 64KB 정도로 잡으면 대부분의 베어메탈 예제가 여유롭습니다.

4) 확인 체크리스트

 lscript.ld의 _heap_size, _stack_size 반영됨

 Build 로그에 같은 overflow 메시지 사라짐

 Vivado에서 Local Memory가 너무 작게(예: 16KB) 잡혀 있지 않은지

---

### 15. 보드 연결 및 실행 (Launch a Vitis Baremetal Software Application)
1) 보드 **JTAG 부트**로 설정(기존 플래시/SD 부트 혼동 방지)  
2) **시리얼 터미널** 연결(표준 출력 확인용)
   - **Zynq**: 115200 baud / **MicroBlaze + AXI UART Lite**: 9600 baud  
   - 흐름 제어: **NONE**  
   - Vitis 내장 터미널은 라인 단위 전송 특성 — 필요 시 **Tera Term/PuTTY** 권장
3) Explorer에서 애플리케이션/시스템 프로젝트 우클릭 →  
   **Run as → 1 Launch on Hardware (Single Application Debug)**  
   - 비트스트림 다운로드 → ELF 로드 → 실행 시작  
   - 이후에는 툴바의 **초록 실행 버튼**으로 재실행 가능

---

## 다음 단계 (Next Steps)
- 현재 애플리케이션이 실행되고, 출력 메시지를 확인할 수 있습니다. **축하합니다!**
- 본 하드웨어/소프트웨어 프로젝트는 추후 작업의 기반으로 재사용할 수 있습니다.  
  하드웨어 갱신 방법: *Update an Existing Vitis Platform's Hardware Specification* 참고
- 보드별 추가 가이드/데모는 **Programmable Logic** 페이지에서 보드 **Resource Center**로 이동하여 확인하세요.
- 기술 지원: **Digilent Forums → FPGA 섹션**

---
