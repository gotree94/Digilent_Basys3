# 🧩 Digilent Basys3 Verilog 기본 문법 정리

## 📚 목차
1. [자료형](#1️⃣-자료형)
2. [파라미터 (Parameter)](#2️⃣-파라미터parameter)
3. [벡터와 배열 (Vector & Array)](#3️⃣-벡터vector와-배열array)
4. [연산자](#4️⃣-연산자)
5. [Verilog의 추상화 수준 모델링](#5️⃣-verilog의-추상화-수준-모델링)
6. [할당문](#6️⃣-할당문)
7. [Always / Initial 문](#7️⃣-always--initial-문)
8. [구조적 설계 (Structural Design)](#8️⃣-구조적-설계-structural-design)
9. [가독성과 효율적 설계 스타일](#9️⃣-가독성과-효율적-설계-스타일)
10. [Tip](#✅-tip)

---

<img width="1080" height="693" alt="001" src="https://github.com/user-attachments/assets/97d51efb-101b-4b4b-919c-305b9596d99e" />
<br>

## 1️⃣ 자료형

### 📘 Net형 (연결선)
- **wire** : 논리적 동작 없이 단순 연결에 사용  
  ```verilog
  wire x;
  ```

### 📘 Register형 (값 저장)
- **reg** : 값을 임시로 저장할 수 있는 변수 (조합/순차회로에서 사용)  
  ```verilog
  reg [3:0] x1, y1, z1;
  ```

### 📘 논리값
| 값 | 의미 |
|:--:|:--|
| `0` | 논리적 0 / 거짓 (GND) |
| `1` | 논리적 1 / 참 (VCC) |
| `X` | 알 수 없는 상태 |
| `Z` | 하이임피던스 (Open / Floating) |

---

## 2️⃣ 파라미터(Parameter)

- 모듈 내 상수 정의에 사용 (비트 폭, 주소 범위 등)
- `parameter`, `localparam` 사용

```verilog
parameter AVG = (x + y) / 2;
```

- 모듈 매개변수화 예시
  ```verilog
  module example_module #(parameter WIDTH = 4) (...);
  module example_module #(.WIDTH(4)) (...);
  ```

---

## 3️⃣ 벡터(Vector)와 배열(Array)

### 📘 벡터
여러 비트로 구성된 비트열

```verilog
wire [3:0] bus_a;
assign bus_a = 4'hF;
```

### 📘 배열
벡터의 집합

```verilog
reg [7:0] array_2d [2:0];       // 2차원 배열
array_2d[2][3] = 8'h00;
```

<img width="1121" height="717" alt="002" src="https://github.com/user-attachments/assets/e05e7f11-1a16-48fa-98f1-a7febe481f7a" />
<br>

---

## 4️⃣ 연산자

| 종류 | 연산자 | 예시 |
|------|---------|------|
| **산술** | `+`, `-`, `*`, `/`, `%` | `assign add = a + b;` |
| **논리** | `&&`, `||`, `!` | `if (a && b)` |
| **비트단위** | `~`, `&`, `|`, `^`, `^~`, `~^` | `(1011) ^ (0011) → (1000)` |
| **관계** | `==`, `!=`, `<`, `<=`, `>`, `>=` | `assign eq = (a==b);` |
| **시프트** | `<<`, `>>`, `<<<`, `>>>` | `0110_1001 >> 2 → 0001_1010` |
| **조건** | `? :` | `y = (a==b) ? a : b;` |
| **결합** | `{ }` | `{1'b1, 1'b0, 2'b01} → 1001` |
| **반복결합** | `{a{b}}` | `{2{01}} → 0101` |

---

## 5️⃣ Verilog의 추상화 수준 모델링

| 수준 | 설명 | 예시 |
|------|------|------|
| **게이트 수준** | 논리 게이트 직접 표현 | `and #(3,4) U0(out, in1, in2);` |
| **데이터플로우 수준** | 연산식 기반 연결 | `assign out = in1 & in2;` |
| **행위 수준** | 기능 중심 표현 (C언어 유사) | `always @(posedge clk)` |

---

## 6️⃣ 할당문

### 📘 연속 할당문 (Continuous Assignment)
- **조합회로용**
- `assign` 사용
- **좌변**: `net형`, **우변**: `net/reg`

```verilog
assign result = a & b;
```
### 📘 절차적 할당문 (Procedural Assignment)
- `always` 또는 `initial` 블록 안에서 사용
- **순차회로**: `<=` (non-blocking)
- **조합회로**: `=` (blocking)

| 구분 | 연산자 | 사용 대상 |
|------|--------|------------|
| 블록킹 | `=` | 조합회로 |
| 논블록킹 | `<=` | 순차회로 |

### ✅ 사용 지침
- 순차회로 → `<=`  
- 조합회로 → `=`  
- 한 `always`문 내에서 `=`와 `<=` 혼용 금지  
- 여러 `always`문에서 동일한 `reg` 사용 금지

<img width="838" height="526" alt="003" src="https://github.com/user-attachments/assets/7f648760-a2d4-4966-984d-bed55fe0788d" />
<br>

<img width="831" height="524" alt="004" src="https://github.com/user-attachments/assets/ce6007c3-cb86-4a4d-b336-2ae99f205699" />
<br>

---

## 7️⃣ Always / Initial 문

### 📘 always 문
- **합성 가능**
- 조합회로, 순차회로, 테스트벤치 등 다양한 용도
- 여러 개 동시에 실행 가능

<img width="847" height="262" alt="005" src="https://github.com/user-attachments/assets/e39bc8ae-0b95-43c9-9139-8391fece8bcb" />
<br>

```verilog
always @(posedge clk or negedge rst)
    if (!rst)
        q <= 0;
    else
        q <= d;
```

### 📘 initial 문
- 초기값 설정, 테스트용 (합성 불가)
- 여러 개 작성 가능, 병렬 실행됨

<img width="856" height="271" alt="006" src="https://github.com/user-attachments/assets/5e0b8e08-bab0-413c-b6f2-c540ad42bb64" />
<br>

```verilog
initial begin
    a = 0; b = 1;
end
```

---

## 8️⃣ 구조적 설계 (Structural Design)

- 전체 시스템을 **모듈 단위로 분할**  
- 하위 모듈을 상위 모듈에 **인스턴스화**하여 연결

### 📘 위치 기반 포트 매핑
```verilog
adder U0 (a, b, sum);
sub_module1 U0 (iIN, s0, s1); 
sub_module2 U1 (s0, s1, oOUT);
```

<img width="1081" height="557" alt="007" src="https://github.com/user-attachments/assets/529029e9-698f-453b-8062-9a42b0b6e155" />
<br>

### 📘 이름 기반 포트 매핑
```verilog
adder U0 (.a(x), .b(y), .sum(z));
sub_module1 U0 (.iA(iIN), .oA1(s1), .oA0(s0)); 
sub_module2 U1 (.iB0(s0), .iB1(s1), .oB(oOUT));
```
<img width="1083" height="555" alt="008" src="https://github.com/user-attachments/assets/da5604cf-156d-4ebf-81b4-d8b2089c4644" />
<br>

### ▶ 구조적 설계를 위한 모델링 방법

<img width="1092" height="657" alt="009" src="https://github.com/user-attachments/assets/29f01b42-5edf-4cc8-9c12-114858ab704b" />
<br>

### ▶ 모델링 검증을 위한 테스트벤치

<img width="817" height="324" alt="010" src="https://github.com/user-attachments/assets/f1b685d6-9c2f-4612-9b22-34f407bc01ef" />
<br>

### ▶ 모델링 검증을 위한 테스트벤치

<img width="1001" height="605" alt="011" src="https://github.com/user-attachments/assets/880aafff-88f9-4851-a7c4-e3e3162480ff" />
<br>
<img width="866" height="441" alt="012" src="https://github.com/user-attachments/assets/11fbec7e-d1ec-4204-8689-0a84f3c3ca94" />
<br>

---

## 9️⃣ 가독성과 효율적 설계 스타일

### 📘 코딩 스타일 가이드
- 일관된 들여쓰기
- 의미 있는 이름 사용
- 클록(`clk`) 및 리셋(`rst_n`) 명확히 표기
- 상수는 `parameter`로 정의
- 포트 선언 순서 정리 (입력→출력)
- 우선순위 없는 조건문 권장 (`case`, `if-else`)

### 📘 효율적 코딩 방법
- `always` 이벤트 목록에 필요한 신호만 포함
- 조건문 기반 조합회로 설계
- 시간 제어 포함 순차회로에서의 `posedge` / `negedge` 정확히 지정

<img width="1004" height="569" alt="013" src="https://github.com/user-attachments/assets/d8573114-214e-4827-9b5a-9c5f388b1b99" />
<br>
<img width="984" height="434" alt="014" src="https://github.com/user-attachments/assets/6d3dc389-e014-4d89-b475-41d199a07ab1" />
<br>

---

## ✅ Tip
Basys3 실습 시에는 항상 `timescale`과 `default_nettype`을 명시하는 습관을 들이세요.

```verilog
`timescale 1ns / 1ps
`default_nettype none
```
