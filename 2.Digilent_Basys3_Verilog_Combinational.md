# 🧩 Digilent Basys3 Verilog 조합회로 모델링

## 🎯 학습목표
- 조합회로의 개념을 이해한다.  
- 논리 게이트를 사용하여 조합회로를 모델링하는 방법을 이해한다.  
- 대표적인 조합회로의 동작을 이해한다.  
- 다양한 추상화 수준 모델링 방법을 사용하여 조합회로를 모델링할 수 있다.  

---

## 📚 목차
1. [조합회로 (Combinational Circuit)](#1-조합회로combinational-circuit)
2. [기본적인 논리 게이트 조합회로](#52-기본적인-논리-게이트-조합회로)
3. [전가산기 (Full Adder)](#53-전가산기)
4. [멀티플렉서 (Multiplexer)](#54-멀티플렉서)
5. [산술 논리 장치 (ALU)](#55-산술-논리-장치)
6. [인코더와 디코더](#56-인코더와-디코더)
7. [코드 변환기 (Binary-BCD)](#58-코드-변환기)

---

## 1. 조합회로(Combinational circuit)

- AND, OR, NOT 등의 여러 논리 게이트의 조합  
- 현재 입력값에 의해 출력값 결정  
- 구성요소: 논리 게이트(logic gate), 도선(wire)  
- 회로 구성 단순, 처리 복잡도가 낮음, 시간 지연 작음  
- 사용 예: 컴퓨터 시스템, 통신 시스템, 디지털 필터, 자동차 시스템  

---

## 5.2 기본적인 논리 게이트 조합회로

### ▶ 설계 및 시뮬레이션 목표
- 게이트 수준(gate level) 모델링으로 조합회로 설계

### 💻 gates - Gate level modeling
```verilog
module gates (iA, iB, oAND, oOR, oNOT, oNAND, oNAND2);
input    iA, iB;
output   oAND, oOR, oNOT, oNAND, oNAND2;
wire     s0;

and    U0 (oAND,   iA, iB);
or     U1 (oOR,    iA, iB);
not    U2 (oNOT,   iA);
nand   U3 (oNAND,  iA, iB);
and    U4 (s0,     iA, iB);
not    U5 (oNAND2, s0);
endmodule
```

### 🧪 gates - Testbench
```verilog
`timescale 1ns/1ps
module tb_gates;
reg    iA, iB;
wire   oAND, oOR, oNOT, oNAND, oNAND2;

// 이름에 의한 포트 매핑 사용
gates U0 (
    .iA(iA),
    .iB(iB),
    .oAND(oAND),
    .oOR(oOR),
    .oNOT(oNOT),
    .oNAND(oNAND),
    .oNAND2(oNAND2)
);

initial begin
    iA = 0; iB = 0; #100;
    iA = 0; iB = 1; #100;
    iA = 1; iB = 0; #100;
    iA = 1; iB = 1; #100;
    $stop;
end
endmodule
```

---

## 5.3 전가산기

### ▶ 전가산기 (Full Adder)
- 두 개의 이진수를 더할 때 사용하는 기본 논리 회로  
- 두 입력, 하나의 carry 입력, sum과 carry 출력  
- 반가산기 2개 + OR 게이트 조합  
- ALU, 메모리 주소 계산 등에 사용

### 💻 Full Adder – Bitwise Logical Operator 1
```verilog
module full_adder (iX, iY, iCIN, oSUM, oCARRY);
input     iX, iY, iCIN;
output    oSUM, oCARRY;
wire      s0, c0, c1;

assign s0 = iX ^ iY;
assign c0 = iX & iY;
assign c1 = s0 & iCIN;
assign oSUM = s0 ^ iCIN;
assign oCARRY = c0 | c1;
endmodule
```

### 💻 Half Adder – Structural Modeling
```verilog
module half_adder (iA, iB, oS, oC);
input  iA, iB;
output oS, oC;
assign oS = iA ^ iB;
assign oC = iA & iB;
endmodule
```

### 💻 Full Adder – Structural Modeling
```verilog
module full_adder (iX, iY, iCIN, oSUM, oCARRY);
input  iX, iY, iCIN;
output oSUM, oCARRY;
wire   s0, c0, c1;

half_adder ha0 (.iA(iX), .iB(iY), .oS(s0), .oC(c0));
half_adder ha1 (.iA(s0), .iB(iCIN), .oS(oSUM), .oC(c1));
assign oCARRY = c0 | c1;
endmodule
```

### 🧪 Full Adder – Testbench
```verilog
`timescale 1ns/1ps
module tb_full_adder;
reg    iX, iY, iCIN;
wire   oSUM, oCARRY;

full_adder UFA (
    .iX(iX),
    .iY(iY),
    .iCIN(iCIN),
    .oSUM(oSUM),
    .oCARRY(oCARRY)
);

initial begin
    iX = 0; iY = 0; iCIN = 0; #100;
    iX = 0; iY = 1; iCIN = 0; #100;
    iX = 1; iY = 0; iCIN = 0; #100;
    iX = 1; iY = 1; iCIN = 1; #100;
end
endmodule
```

---

## 5.4 멀티플렉서

### ▶ 멀티플렉서 (MUX)
- 여러 입력 중 하나를 선택하여 출력으로 전달  
- 데이터 선택기(data selector), 데이터 경로 제어에 사용

### 💻 MUX 4x1 – Conditional Operator
```verilog
module mux (iA, iB, iC, iD, iSEL, oOUT);
input     [7:0] iA, iB, iC, iD;
input     [1:0] iSEL;
output    [7:0] oOUT;

assign oOUT = (iSEL == 0) ? iA :
              (iSEL == 1) ? iB :
              (iSEL == 2) ? iC : iD;
endmodule
```

### 💻 MUX 4x1 – Case
```verilog
module mux (iA, iB, iC, iD, iSEL, oOUT);
input     [7:0] iA, iB, iC, iD;
input     [1:0] iSEL;
output    [7:0] oOUT;
reg       [7:0] out;

always @(iA or iB or iC or iD or iSEL) begin
    case(iSEL)
        0: out = iA;
        1: out = iB;
        2: out = iC;
        default: out = iD;
    endcase
end

assign oOUT = out;
endmodule
```

---

## 5.5 산술 논리 장치 (ALU)

### ▶ ALU (Arithmetic Logic Unit)
- 덧셈, 뺄셈, 곱셈, 논리연산, 시프트 연산 등 수행

### 💻 ALU 4bit – Case
```verilog
module alu (iA, iB, iINST, oRESULT);
localparam  ADD = 4'h0, SUB = 4'h1, MUL = 4'h2, DIV = 4'h3, MOD = 4'h4,
            BIT_NOT = 4'h5, BIT_AND = 4'h6, BIT_OR = 4'h7, BIT_XOR = 4'h8,
            BIT_XNOR = 4'h9, RED_AND = 4'ha, RED_OR = 4'hb,
            RED_NAND = 4'hc, RED_XOR = 4'hd, RSHFT = 4'he, LSHFT = 4'hf;

input     [3:0] iA, iB, iINST;
output    [7:0] oRESULT;
reg       [7:0] result;

always @(iA or iB or iINST) begin
    case(iINST)
        ADD: result = iA + iB;
        SUB: result = iA - iB;
        MUL: result = iA * iB;
        DIV: result = iA / iB;
        MOD: result = iA % iB;
        BIT_NOT: result = ~iA;
        BIT_AND: result = iA & iB;
        BIT_OR: result = iA | iB;
        BIT_XOR: result = iA ^ iB;
        BIT_XNOR: result = iA ~^ iB;
        RED_AND: result = &iA;
        RED_OR: result = |iA;
        RED_NAND: result = ~&iA;
        RED_XOR: result = ^iA;
        RSHFT: result = iA >> iB;
        LSHFT: result = iA << iB;
        default: result = 8'h00;
    endcase
end
assign oRESULT = result;
endmodule
```

---

## 5.6 인코더와 디코더

### 💻 Encoder – Case
```verilog
module encoder (iIN, oOUT);
input     [9:0] iIN;
output    [3:0] oOUT;
reg       [3:0] out;

always @(iIN) begin
    case(iIN)
        10'b00_0000_0001: out = 4'b0000;
        10'b00_0000_0010: out = 4'b0001;
        10'b00_0000_0100: out = 4'b0010;
        10'b10_0000_0000: out = 4'b1001;
        default: out = 4'b1111;
    endcase
end
assign oOUT = out;
endmodule
```

---

## 5.8 코드 변환기

### 💻 Binary-BCD 변환기 – if문 사용
```verilog
module bin2bcd (iBIN, oBCD);
input    [7:0]  iBIN;
output   [11:0] oBCD;
reg      [11:0] bcd;
integer  i;
assign   oBCD = bcd;

always @(iBIN) begin
    bcd = 12'b0;
    for (i = 0; i < 8; i = i + 1) begin
        if (bcd[3:0] >= 5) bcd[3:0] = bcd[3:0] + 3;
        if (bcd[7:4] >= 5) bcd[7:4] = bcd[7:4] + 3;
        if (bcd[11:8] >= 5) bcd[11:8] = bcd[11:8] + 3;
        bcd = {bcd[10:0], iBIN[7 - i]};
    end
end
endmodule
```

---
