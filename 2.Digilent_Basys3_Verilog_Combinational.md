# ðŸ§© Digilent Basys3 Verilog ì¡°í•©íšŒë¡œ ëª¨ë¸ë§

## ðŸŽ¯ í•™ìŠµëª©í‘œ
- ì¡°í•©íšŒë¡œì˜ ê°œë…ì„ ì´í•´í•œë‹¤.  
- ë…¼ë¦¬ ê²Œì´íŠ¸ë¥¼ ì‚¬ìš©í•˜ì—¬ ì¡°í•©íšŒë¡œë¥¼ ëª¨ë¸ë§í•˜ëŠ” ë°©ë²•ì„ ì´í•´í•œë‹¤.  
- ëŒ€í‘œì ì¸ ì¡°í•©íšŒë¡œì˜ ë™ìž‘ì„ ì´í•´í•œë‹¤.  
- ë‹¤ì–‘í•œ ì¶”ìƒí™” ìˆ˜ì¤€ ëª¨ë¸ë§ ë°©ë²•ì„ ì‚¬ìš©í•˜ì—¬ ì¡°í•©íšŒë¡œë¥¼ ëª¨ë¸ë§í•  ìˆ˜ ìžˆë‹¤.  

---

## ðŸ“š ëª©ì°¨
1. [ì¡°í•©íšŒë¡œ (Combinational Circuit)](#1-ì¡°í•©íšŒë¡œcombinational-circuit)
2. [ê¸°ë³¸ì ì¸ ë…¼ë¦¬ ê²Œì´íŠ¸ ì¡°í•©íšŒë¡œ](#52-ê¸°ë³¸ì ì¸-ë…¼ë¦¬-ê²Œì´íŠ¸-ì¡°í•©íšŒë¡œ)
3. [ì „ê°€ì‚°ê¸° (Full Adder)](#53-ì „ê°€ì‚°ê¸°)
4. [ë©€í‹°í”Œë ‰ì„œ (Multiplexer)](#54-ë©€í‹°í”Œë ‰ì„œ)
5. [ì‚°ìˆ  ë…¼ë¦¬ ìž¥ì¹˜ (ALU)](#55-ì‚°ìˆ -ë…¼ë¦¬-ìž¥ì¹˜)
6. [ì¸ì½”ë”ì™€ ë””ì½”ë”](#56-ì¸ì½”ë”ì™€-ë””ì½”ë”)
7. [ì½”ë“œ ë³€í™˜ê¸° (Binary-BCD)](#58-ì½”ë“œ-ë³€í™˜ê¸°)

---

## 1. ì¡°í•©íšŒë¡œ(Combinational circuit)

- AND, OR, NOT ë“±ì˜ ì—¬ëŸ¬ ë…¼ë¦¬ ê²Œì´íŠ¸ì˜ ì¡°í•©  
- í˜„ìž¬ ìž…ë ¥ê°’ì— ì˜í•´ ì¶œë ¥ê°’ ê²°ì •  
- êµ¬ì„±ìš”ì†Œ: ë…¼ë¦¬ ê²Œì´íŠ¸(logic gate), ë„ì„ (wire)  
- íšŒë¡œ êµ¬ì„± ë‹¨ìˆœ, ì²˜ë¦¬ ë³µìž¡ë„ê°€ ë‚®ìŒ, ì‹œê°„ ì§€ì—° ìž‘ìŒ  
- ì‚¬ìš© ì˜ˆ: ì»´í“¨í„° ì‹œìŠ¤í…œ, í†µì‹  ì‹œìŠ¤í…œ, ë””ì§€í„¸ í•„í„°, ìžë™ì°¨ ì‹œìŠ¤í…œ  

---

## 5.2 ê¸°ë³¸ì ì¸ ë…¼ë¦¬ ê²Œì´íŠ¸ ì¡°í•©íšŒë¡œ

### â–¶ ì„¤ê³„ ë° ì‹œë®¬ë ˆì´ì…˜ ëª©í‘œ
- ê²Œì´íŠ¸ ìˆ˜ì¤€(gate level) ëª¨ë¸ë§ìœ¼ë¡œ ì¡°í•©íšŒë¡œ ì„¤ê³„

### ðŸ’» gates - Gate level modeling
```verilog
module gates (iA, iB, oAND, oOR, oNOT, oNAND, oNAND2);
input    iA, iB;
output   oAND, oOR, oNOT, oNAND, oNAND2;
wire     s0;

and    U0 (oAND,   iA, iB);
or     U1 (oOR,    iA, iB);
not    U2 (oNOT,   iA);
nand   U3 (oNAND,  iA, iB);
and    U4 (s0,     iA, iB);
not    U5 (oNAND2, s0);
endmodule
```

### ðŸ§ª gates - Testbench
```verilog
`timescale 1ns/1ps
module tb_gates;
reg    iA, iB;
wire   oAND, oOR, oNOT, oNAND, oNAND2;

// ì´ë¦„ì— ì˜í•œ í¬íŠ¸ ë§¤í•‘ ì‚¬ìš©
gates U0 (
    .iA(iA),
    .iB(iB),
    .oAND(oAND),
    .oOR(oOR),
    .oNOT(oNOT),
    .oNAND(oNAND),
    .oNAND2(oNAND2)
);

initial begin
    iA = 0; iB = 0; #100;
    iA = 0; iB = 1; #100;
    iA = 1; iB = 0; #100;
    iA = 1; iB = 1; #100;
    $stop;
end
endmodule
```

---

## 5.3 ì „ê°€ì‚°ê¸°

### â–¶ ì „ê°€ì‚°ê¸° (Full Adder)
- ë‘ ê°œì˜ ì´ì§„ìˆ˜ë¥¼ ë”í•  ë•Œ ì‚¬ìš©í•˜ëŠ” ê¸°ë³¸ ë…¼ë¦¬ íšŒë¡œ  
- ë‘ ìž…ë ¥, í•˜ë‚˜ì˜ carry ìž…ë ¥, sumê³¼ carry ì¶œë ¥  
- ë°˜ê°€ì‚°ê¸° 2ê°œ + OR ê²Œì´íŠ¸ ì¡°í•©  
- ALU, ë©”ëª¨ë¦¬ ì£¼ì†Œ ê³„ì‚° ë“±ì— ì‚¬ìš©

### ðŸ’» Full Adder â€“ Bitwise Logical Operator 1
```verilog
module full_adder (iX, iY, iCIN, oSUM, oCARRY);
input     iX, iY, iCIN;
output    oSUM, oCARRY;
wire      s0, c0, c1;

assign s0 = iX ^ iY;
assign c0 = iX & iY;
assign c1 = s0 & iCIN;
assign oSUM = s0 ^ iCIN;
assign oCARRY = c0 | c1;
endmodule
```

### ðŸ’» Half Adder â€“ Structural Modeling
```verilog
module half_adder (iA, iB, oS, oC);
input  iA, iB;
output oS, oC;
assign oS = iA ^ iB;
assign oC = iA & iB;
endmodule
```

### ðŸ’» Full Adder â€“ Structural Modeling
```verilog
module full_adder (iX, iY, iCIN, oSUM, oCARRY);
input  iX, iY, iCIN;
output oSUM, oCARRY;
wire   s0, c0, c1;

half_adder ha0 (.iA(iX), .iB(iY), .oS(s0), .oC(c0));
half_adder ha1 (.iA(s0), .iB(iCIN), .oS(oSUM), .oC(c1));
assign oCARRY = c0 | c1;
endmodule
```

### ðŸ§ª Full Adder â€“ Testbench
```verilog
`timescale 1ns/1ps
module tb_full_adder;
reg    iX, iY, iCIN;
wire   oSUM, oCARRY;

full_adder UFA (
    .iX(iX),
    .iY(iY),
    .iCIN(iCIN),
    .oSUM(oSUM),
    .oCARRY(oCARRY)
);

initial begin
    iX = 0; iY = 0; iCIN = 0; #100;
    iX = 0; iY = 1; iCIN = 0; #100;
    iX = 1; iY = 0; iCIN = 0; #100;
    iX = 1; iY = 1; iCIN = 1; #100;
end
endmodule
```

---

## 5.4 ë©€í‹°í”Œë ‰ì„œ

### â–¶ ë©€í‹°í”Œë ‰ì„œ (MUX)
- ì—¬ëŸ¬ ìž…ë ¥ ì¤‘ í•˜ë‚˜ë¥¼ ì„ íƒí•˜ì—¬ ì¶œë ¥ìœ¼ë¡œ ì „ë‹¬  
- ë°ì´í„° ì„ íƒê¸°(data selector), ë°ì´í„° ê²½ë¡œ ì œì–´ì— ì‚¬ìš©

### ðŸ’» MUX 4x1 â€“ Conditional Operator
```verilog
module mux (iA, iB, iC, iD, iSEL, oOUT);
input     [7:0] iA, iB, iC, iD;
input     [1:0] iSEL;
output    [7:0] oOUT;

assign oOUT = (iSEL == 0) ? iA :
              (iSEL == 1) ? iB :
              (iSEL == 2) ? iC : iD;
endmodule
```

### ðŸ’» MUX 4x1 â€“ Case
```verilog
module mux (iA, iB, iC, iD, iSEL, oOUT);
input     [7:0] iA, iB, iC, iD;
input     [1:0] iSEL;
output    [7:0] oOUT;
reg       [7:0] out;

always @(iA or iB or iC or iD or iSEL) begin
    case(iSEL)
        0: out = iA;
        1: out = iB;
        2: out = iC;
        default: out = iD;
    endcase
end

assign oOUT = out;
endmodule
```

---

## 5.5 ì‚°ìˆ  ë…¼ë¦¬ ìž¥ì¹˜ (ALU)

### â–¶ ALU (Arithmetic Logic Unit)
- ë§ì…ˆ, ëº„ì…ˆ, ê³±ì…ˆ, ë…¼ë¦¬ì—°ì‚°, ì‹œí”„íŠ¸ ì—°ì‚° ë“± ìˆ˜í–‰

### ðŸ’» ALU 4bit â€“ Case
```verilog
module alu (iA, iB, iINST, oRESULT);
localparam  ADD = 4'h0, SUB = 4'h1, MUL = 4'h2, DIV = 4'h3, MOD = 4'h4,
            BIT_NOT = 4'h5, BIT_AND = 4'h6, BIT_OR = 4'h7, BIT_XOR = 4'h8,
            BIT_XNOR = 4'h9, RED_AND = 4'ha, RED_OR = 4'hb,
            RED_NAND = 4'hc, RED_XOR = 4'hd, RSHFT = 4'he, LSHFT = 4'hf;

input     [3:0] iA, iB, iINST;
output    [7:0] oRESULT;
reg       [7:0] result;

always @(iA or iB or iINST) begin
    case(iINST)
        ADD: result = iA + iB;
        SUB: result = iA - iB;
        MUL: result = iA * iB;
        DIV: result = iA / iB;
        MOD: result = iA % iB;
        BIT_NOT: result = ~iA;
        BIT_AND: result = iA & iB;
        BIT_OR: result = iA | iB;
        BIT_XOR: result = iA ^ iB;
        BIT_XNOR: result = iA ~^ iB;
        RED_AND: result = &iA;
        RED_OR: result = |iA;
        RED_NAND: result = ~&iA;
        RED_XOR: result = ^iA;
        RSHFT: result = iA >> iB;
        LSHFT: result = iA << iB;
        default: result = 8'h00;
    endcase
end
assign oRESULT = result;
endmodule
```

---

## 5.6 ì¸ì½”ë”ì™€ ë””ì½”ë”

### ðŸ’» Encoder â€“ Case
```verilog
module encoder (iIN, oOUT);
input     [9:0] iIN;
output    [3:0] oOUT;
reg       [3:0] out;

always @(iIN) begin
    case(iIN)
        10'b00_0000_0001: out = 4'b0000;
        10'b00_0000_0010: out = 4'b0001;
        10'b00_0000_0100: out = 4'b0010;
        10'b10_0000_0000: out = 4'b1001;
        default: out = 4'b1111;
    endcase
end
assign oOUT = out;
endmodule
```

---

## 5.8 ì½”ë“œ ë³€í™˜ê¸°

### ðŸ’» Binary-BCD ë³€í™˜ê¸° â€“ ifë¬¸ ì‚¬ìš©
```verilog
module bin2bcd (iBIN, oBCD);
input    [7:0]  iBIN;
output   [11:0] oBCD;
reg      [11:0] bcd;
integer  i;
assign   oBCD = bcd;

always @(iBIN) begin
    bcd = 12'b0;
    for (i = 0; i < 8; i = i + 1) begin
        if (bcd[3:0] >= 5) bcd[3:0] = bcd[3:0] + 3;
        if (bcd[7:4] >= 5) bcd[7:4] = bcd[7:4] + 3;
        if (bcd[11:8] >= 5) bcd[11:8] = bcd[11:8] + 3;
        bcd = {bcd[10:0], iBIN[7 - i]};
    end
end
endmodule
```

---
