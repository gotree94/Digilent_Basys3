# 🧩 Digilent Basys3 Verilog 조합회로 모델링

## 🎯 학습목표
- 조합회로의 개념을 이해한다.  
- 논리 게이트를 사용하여 조합회로를 모델링하는 방법을 이해한다.  
- 대표적인 조합회로의 동작을 이해한다.  
- 다양한 추상화 수준 모델링 방법을 사용하여 조합회로를 모델링할 수 있다.  

---

## 📚 목차
1. [조합회로 (Combinational Circuit)](#1-조합회로combinational-circuit)
2. [기본적인 논리 게이트 조합회로](#2-기본적인-논리-게이트-조합회로)
3. [전가산기 (Full Adder)](#3-전가산기)
4. [멀티플렉서 (Multiplexer)](#4-멀티플렉서)
5. [산술 논리 장치 (ALU)](#5-산술-논리-장치)
6. [인코더와 디코더](#6-인코더와-디코더)
7. [코드 변환기 (Binary-BCD)](#7-코드-변환기)

---

<img width="300" height="150" alt="001" src="https://github.com/user-attachments/assets/61d35cd4-4a0b-4370-8cd9-4655a9b99010" />

## 1. 조합회로(Combinational circuit)

- AND, OR, NOT 등의 여러 논리 게이트의 조합  
- 현재 입력값에 의해 출력값 결정  
- 구성요소: 논리 게이트(logic gate), 도선(wire)  
- 회로 구성 단순, 처리 복잡도가 낮음, 시간 지연 작음  
- 사용 예: 컴퓨터 시스템, 통신 시스템, 디지털 필터, 자동차 시스템  

<img width="539" height="581" alt="002" src="https://github.com/user-attachments/assets/a6c6f276-3293-4ebd-b51c-636c62f3c17a" />
<br>
<img width="1078" height="562" alt="003" src="https://github.com/user-attachments/assets/f9d47066-9e9f-47b6-b5ca-a4faf46bf6e8" />
<br>

---

## 2. 기본적인 논리 게이트 조합회로

### ▶ 설계 및 시뮬레이션 목표
- 게이트 수준(gate level) 모델링으로 조합회로 설계

### 💻 gates - Gate level modeling
```verilog
module gates (iA, iB, oAND, oOR, oNOT, oNAND, oNAND2);
input    iA, iB;
output   oAND, oOR, oNOT, oNAND, oNAND2;
wire     s0;

and    U0 (oAND,   iA, iB);
or     U1 (oOR,    iA, iB);
not    U2 (oNOT,   iA);
nand   U3 (oNAND,  iA, iB);
and    U4 (s0,     iA, iB);
not    U5 (oNAND2, s0);
endmodule
```

### 🧪 gates - Testbench
```verilog
`timescale 1ns/1ps
module tb_gates;
reg    iA, iB;
wire   oAND, oOR, oNOT, oNAND, oNAND2;

// 이름에 의한 포트 매핑 사용
gates U0 (
    .iA(iA),
    .iB(iB),
    .oAND(oAND),
    .oOR(oOR),
    .oNOT(oNOT),
    .oNAND(oNAND),
    .oNAND2(oNAND2)
);

initial begin
    iA = 0; iB = 0; #100;
    iA = 0; iB = 1; #100;
    iA = 1; iB = 0; #100;
    iA = 1; iB = 1; #100;
    $stop;
end
endmodule
```

---

## 3. 전가산기

### ▶ 전가산기 (Full Adder)
- 두 개의 이진수를 더할 때 사용하는 기본 논리 회로  
- 두 입력, 하나의 carry 입력, sum과 carry 출력  
- 반가산기 2개 + OR 게이트 조합  
- ALU, 메모리 주소 계산 등에 사용


<img width="1149" height="410" alt="005" src="https://github.com/user-attachments/assets/7ff9074e-2692-4d88-8efb-cc8b3f91c7ea" />
<br>
<img width="799" height="469" alt="004" src="https://github.com/user-attachments/assets/da703df3-b6f2-4d91-a241-77499d4a4679" />
<br>

<img width="909" height="275" alt="020" src="https://github.com/user-attachments/assets/b4d4c999-9a61-42e4-932a-45d43aad5ef6" />
<img width="829" height="722" alt="019" src="https://github.com/user-attachments/assets/09ee67a3-e443-44ee-ac1a-0c37fa30cac5" />
<img width="915" height="368" alt="018" src="https://github.com/user-attachments/assets/05012f95-9f9d-4ba0-8182-52e366916a88" />
<img width="937" height="637" alt="017" src="https://github.com/user-attachments/assets/fd67c02e-b8e1-4916-8cf8-fe246d37222d" />
<img width="588" height="542" alt="016" src="https://github.com/user-attachments/assets/2b97c7c2-8992-47d9-acb4-d05bebb9c80b" />
<img width="980" height="643" alt="015" src="https://github.com/user-attachments/assets/7a4f1408-41ac-4e41-a842-8be34d903295" />
<img width="810" height="551" alt="014" src="https://github.com/user-attachments/assets/1f32c850-a635-4bd5-89b9-12d4b86e00ad" />
<img width="943" height="464" alt="013" src="https://github.com/user-attachments/assets/9465a88e-fb5b-479b-aa33-808a034198b2" />
<img width="1028" height="659" alt="012" src="https://github.com/user-attachments/assets/80b54f40-a419-4dd6-b7a4-885443487a23" />
<img width="605" height="433" alt="011" src="https://github.com/user-attachments/assets/3029577e-e0ee-42ec-b379-172c41028015" />
<img width="588" height="407" alt="010" src="https://github.com/user-attachments/assets/75e73b22-65b8-4c87-8651-56e06d1f1621" />
<img width="1051" height="544" alt="009" src="https://github.com/user-attachments/assets/037ae168-11f9-41b0-a793-ececc035dc81" />
<img width="535" height="410" alt="008" src="https://github.com/user-attachments/assets/565809e9-9472-45a0-b5f2-7279e2ce2c82" />
<img width="1006" height="526" alt="007" src="https://github.com/user-attachments/assets/4c22a7a9-5aaa-4749-8da0-f3498d9d86e3" />
<img width="1082" height="415" alt="006" src="https://github.com/user-attachments/assets/5d218adb-1e81-4860-8b6c-5f7e7cda719c" />

### 💻 Full Adder – Bitwise Logical Operator 1
```verilog
module full_adder (iX, iY, iCIN, oSUM, oCARRY);
input     iX, iY, iCIN;
output    oSUM, oCARRY;
wire      s0, c0, c1;

assign s0 = iX ^ iY;
assign c0 = iX & iY;
assign c1 = s0 & iCIN;
assign oSUM = s0 ^ iCIN;
assign oCARRY = c0 | c1;
endmodule
```

### 💻 Half Adder – Structural Modeling
```verilog
module half_adder (iA, iB, oS, oC);
input  iA, iB;
output oS, oC;
assign oS = iA ^ iB;
assign oC = iA & iB;
endmodule
```

### 💻 Full Adder – Structural Modeling
```verilog
module full_adder (iX, iY, iCIN, oSUM, oCARRY);
input  iX, iY, iCIN;
output oSUM, oCARRY;
wire   s0, c0, c1;

half_adder ha0 (.iA(iX), .iB(iY), .oS(s0), .oC(c0));
half_adder ha1 (.iA(s0), .iB(iCIN), .oS(oSUM), .oC(c1));
assign oCARRY = c0 | c1;
endmodule
```

### 🧪 Full Adder – Testbench
```verilog
`timescale 1ns/1ps
module tb_full_adder;
reg    iX, iY, iCIN;
wire   oSUM, oCARRY;

full_adder UFA (
    .iX(iX),
    .iY(iY),
    .iCIN(iCIN),
    .oSUM(oSUM),
    .oCARRY(oCARRY)
);

initial begin
    iX = 0; iY = 0; iCIN = 0; #100;
    iX = 0; iY = 1; iCIN = 0; #100;
    iX = 1; iY = 0; iCIN = 0; #100;
    iX = 1; iY = 1; iCIN = 1; #100;
end
endmodule
```

---

## 4. 멀티플렉서

### ▶ 멀티플렉서 (MUX)
- 여러 입력 중 하나를 선택하여 출력으로 전달  
- 데이터 선택기(data selector), 데이터 경로 제어에 사용

### 💻 MUX 4x1 – Conditional Operator
```verilog
module mux (iA, iB, iC, iD, iSEL, oOUT);
input     [7:0] iA, iB, iC, iD;
input     [1:0] iSEL;
output    [7:0] oOUT;

assign oOUT = (iSEL == 0) ? iA :
              (iSEL == 1) ? iB :
              (iSEL == 2) ? iC : iD;
endmodule
```

### 💻 MUX 4x1 – Case
```verilog
module mux (iA, iB, iC, iD, iSEL, oOUT);
input     [7:0] iA, iB, iC, iD;
input     [1:0] iSEL;
output    [7:0] oOUT;
reg       [7:0] out;

always @(iA or iB or iC or iD or iSEL) begin
    case(iSEL)
        0: out = iA;
        1: out = iB;
        2: out = iC;
        default: out = iD;
    endcase
end

assign oOUT = out;
endmodule
```

---

## 5. 산술 논리 장치 (ALU)

### ▶ ALU (Arithmetic Logic Unit)
- 덧셈, 뺄셈, 곱셈, 논리연산, 시프트 연산 등 수행

### 💻 ALU 4bit – Case
```verilog
module alu (iA, iB, iINST, oRESULT);
localparam  ADD = 4'h0, SUB = 4'h1, MUL = 4'h2, DIV = 4'h3, MOD = 4'h4,
            BIT_NOT = 4'h5, BIT_AND = 4'h6, BIT_OR = 4'h7, BIT_XOR = 4'h8,
            BIT_XNOR = 4'h9, RED_AND = 4'ha, RED_OR = 4'hb,
            RED_NAND = 4'hc, RED_XOR = 4'hd, RSHFT = 4'he, LSHFT = 4'hf;

input     [3:0] iA, iB, iINST;
output    [7:0] oRESULT;
reg       [7:0] result;

always @(iA or iB or iINST) begin
    case(iINST)
        ADD: result = iA + iB;
        SUB: result = iA - iB;
        MUL: result = iA * iB;
        DIV: result = iA / iB;
        MOD: result = iA % iB;
        BIT_NOT: result = ~iA;
        BIT_AND: result = iA & iB;
        BIT_OR: result = iA | iB;
        BIT_XOR: result = iA ^ iB;
        BIT_XNOR: result = iA ~^ iB;
        RED_AND: result = &iA;
        RED_OR: result = |iA;
        RED_NAND: result = ~&iA;
        RED_XOR: result = ^iA;
        RSHFT: result = iA >> iB;
        LSHFT: result = iA << iB;
        default: result = 8'h00;
    endcase
end
assign oRESULT = result;
endmodule
```

---

## 6. 인코더와 디코더

### 💻 Encoder – Case
```verilog
module encoder (iIN, oOUT);
input     [9:0] iIN;
output    [3:0] oOUT;
reg       [3:0] out;

always @(iIN) begin
    case(iIN)
        10'b00_0000_0001: out = 4'b0000;
        10'b00_0000_0010: out = 4'b0001;
        10'b00_0000_0100: out = 4'b0010;
        10'b10_0000_0000: out = 4'b1001;
        default: out = 4'b1111;
    endcase
end
assign oOUT = out;
endmodule
```

---

## 7. 코드 변환기

### 💻 Binary-BCD 변환기 – if문 사용
```verilog
module bin2bcd (iBIN, oBCD);
input    [7:0]  iBIN;
output   [11:0] oBCD;
reg      [11:0] bcd;
integer  i;
assign   oBCD = bcd;

always @(iBIN) begin
    bcd = 12'b0;
    for (i = 0; i < 8; i = i + 1) begin
        if (bcd[3:0] >= 5) bcd[3:0] = bcd[3:0] + 3;
        if (bcd[7:4] >= 5) bcd[7:4] = bcd[7:4] + 3;
        if (bcd[11:8] >= 5) bcd[11:8] = bcd[11:8] + 3;
        bcd = {bcd[10:0], iBIN[7 - i]};
    end
end
endmodule
```
<img width="600" height="300" alt="021" src="https://github.com/user-attachments/assets/24d2555b-52d3-44c9-97c1-5832a56d0443" />
<br>
<img width="600" height="300" alt="022" src="https://github.com/user-attachments/assets/6f83a89e-24dd-4365-bf92-79e4987a4102" />
<br>

---
