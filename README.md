# Digilent_Basys3

## 기본문법
1. 자료형
   – 네트(net)형: 소자 사이의 물리적 연결
     • wire: 논리적 행동이나 기능 없이 단순한 연결에 사용
     • 자료형 선언 예시: wire x;
   – 레지스터(reg)형: 값을 임시로 저장할 수 있는 대상(객체)
     • reg: 크기를 가지나 부호가 없는 정수를 갖는 변수로 실제 설계에서 사용
     • 자료형 선언 예시: reg [3:0] x1, y1, … , z1;
   – 논리값
     • 0: 논리적 0 또는 거짓 상태, 하드웨어적으로 접지
     • 1: 논리적 1 또는 참 상태, 하드웨어적으로 전원 전압
     • X: 알 수 없는 논리값
     • Z: 하이임피던스, 개방(open) 또는 플로팅(floating) 상태

2.▶ 자료형
– 파라미터(parameter): 모듈 내에서 상수 값을 정의
• 비트 폭, 주소 범위 등 하드웨어 구성에 관련된 상숫값을 정의할 때 주로 사용
• parameter, localparam
• 선언 예시: parameter AVG = (x + y) / 2;
• 인스턴스화 시 모듈 매개 변수 사용 예시
◇ module example_module #(parameter WIDTH = 4) (port mapping)
◇ module example_module #(.WIDTH(4)) (port mapping)


▶ 벡터와 배열
– 벡터(vector): 여러 개의 비트로 구성된 비트 열(bit sequence)
• 선언 형식: 자료형 [MSB : LSB] 벡터_이름;
• 할당 예시: bus_a [3:0] = 4’hf; – 배열(array): 벡터들의 묶음
• 선언 형식: 자료형 [MSB : LSB] 배열_이름 [upper_address : lower_address];
• 할당 예시1: array_2d [2][3] 8’h00;
• 할당 예시2: array_2d [2][3:0] 8’h00;


▶ 연산자
– 산술연산자: +, -, *, /, %
• 사용 예: assign add = (a + b);
– 논리연산자: &&, ||, !
• 사용 예: if (a && b) …
– 비트단위 논리연산자: ~, &, |, ^, ^~, ~^
• 사용 예: (1011) ^ (0011) -> (1000)
– 비트단항 논리연산자: ~, &, |, ^, ^~, ~^
• 사용 예: & (0101) = 0 -> (0 〮 1 〮 0 〮 1) = 0 – 관계연산자: ==. !=, <, <=, >, >=
• 사용 예: assign equal = (a==b); -> a=b이면 equal = 1
– 시프트연산자: >>, <<, >>>, <<<
• 사용 예1: 0110_1001 >> 2 -> 0001_1010
• 사용 예2: 1_100 >>> 2 -> 1_111
– 조건연산자: ? :
• 사용 예: y = (a==b) ? a : b ;
– 결합연산자: { }
• 사용 예: assign a = {1’b1, 1’b0, 2’b01} -> a = 1001 – 반복연산자 {a{b}}
• 사용 예: assign a = {2{01}}; -> a = 0101


▶ Verilog의 추상화 수준 모델링
– 게이트 수준 모델링(gate level modeling)
• 회로의 구성 상태를 직접 모델링할 수 있음
• primitive logic gates
• primitive_operator_name #(전달지연시간) 인스턴스_이름 (입출력_목록);
• and #(3, 4) U0 (output, input1, input2);     //상승지연 3ns, 하강지연 4ns – 데이터플로우 수준 모델링(dataflow level modeling)
• 논리게이트와 같은 회로 구성요소들의 입출력 사이의 연결과 함께 산술연산, 논 리연산 등 다양한 기능을 갖는 연산 블록을 이용하는 모델링 방법
• assign (신호강도) #(지연 값) net형 신호나 벡터의 이름 = 할당 값 또는 연산식;
• assign out = in1 & in2;
– 행위 수준 모델링(behavioral level modeling)
• 회로도나 논리식을 고려하지 않고 회로의 기능적 측면을 고려
• C언어 프로그래밍과 유사


▶ 할당문
– 연속 할당문(continuous assignment)
• assign 문을 이용하여 net형 객체에 스칼라 또는 벡터 형태의 값을 할당
• 우변 값 변화 -> 즉시 좌변 객체에 값 할당
• 조합회로에서 사용
• 주의 사항
◇ 할당연산자 좌변: reg형 사용 X
◇ 할당연산자 우변: net/reg 스칼라 or 벡터 or 함수 호출문
•   사용 예: assign result = a & b;

– 절차형 할당문(procedural assignment)
• (blocking assignment statement, =), (nonblocking assignment statement, <=)
• always문 또는 initial문에서 ‘=‘ 또는 ‘<=‘를 사용하여 reg형 객체의 값을 갱신
• event_signal 값의 변화 발생 시 좌변 객체에 값 할당
• 값이 갱신될 때까지 값 유지
• 주로 순차회로에서 사용, 조합회로에서도 사용 가능

– 블록킹 할당문과 논블록킹 할당문의 사용 지침
• 순차 논리회로를 모델링할 때 ‘<=‘ 사용
• 조합 논리회로를 always문으로 구현할 때 ‘=‘ 사용
• always문에서 순차회로 구현 시 ‘<=‘ 사용
• always문 내에서 ‘=‘과 ‘<=‘ 혼용 X
• 2개 이상의 always문 내에서 동일한 reg 자료형에 할당 X

– always 문
• 행위 수준 모델링의 기본 구문
• 논리합성 가능 -> 실제 하드웨어 구현 가능
• 조합회로, 순차회로, 테스트벤치 작성에 사용 가능
• 여러 개 사용 가능, 동시 실행

– initial 문
• 특정 값으로 초기화, 회로 초기 상태 설정, 입력신호나 파형 생성에 사용
• 논리합성 X -> 테스트벤치에서 사용
• 여러 개 사용 가능, 동시 실행


▶ 구조적 설계를 위한 모델링 방법
– 구조 기반 모델링 방법: 전체 시스템 -> 서브 시스템으로 분할 – 인스턴스화 -> 상위모듈에 포함, 입출력 포트 연결
– 위치에 의한 포트 맵핑
• 하위모듈_이름 인스턴스_이름 (상위모듈_포트이름1, 상위모듈_포트이름2, …); – 이름에 의한 포트 맵핑
• 하위모듈_이름 인스턴스_이름 (.하위모듈_포트이름2(상위모듈_포트이름2), …);

---

▶ 가독성을 높이는 코딩 스타일
– 들여쓰기
– 모듈 이름과 신호 이름의 작성 – 클록과 리셋 신호의 이름
– 상수 설정
– 포트 선언 순서
– 모듈의 인스턴스화 시 포트 맵핑 – 우선순위가 없는 조건문

▶ 효율적인 설계를 위한 코딩 방법
– 조건문을 사용한 모델링
– 시간 제어가 포함된 순차회로 모델링에서 always문의 이벤트 신호목록 작 성
– 신호의 값 표현






